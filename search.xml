<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>网络与安全-关于CSRF攻击</title>
    <url>/2020/08/03/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/%E5%85%B3%E4%BA%8ECSRF%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<blockquote>
<p>网络千万条，安全第一条，网安不规范，网站都完蛋！</p>
</blockquote>
<a id="more"></a>

<h3 id="什么是CSRF攻击"><a href="#什么是CSRF攻击" class="headerlink" title="什么是CSRF攻击"></a>什么是CSRF攻击</h3><ul>
<li>CSRF概念：CSRF（Cross-site request forgery）跨站请求伪造，也被称为”One Click Attact”或者Session Riding,通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。</li>
<li>尽管听起来像跨站脚本(XSS),但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装为受信任用户的请求来利用受信任网站。</li>
<li>与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具有危险性。</li>
</ul>
<h3 id="造成CSRF攻击原理"><a href="#造成CSRF攻击原理" class="headerlink" title="造成CSRF攻击原理"></a>造成CSRF攻击原理</h3><ul>
<li>发送请求自动带上cookie：浏览器HTTP(s)请求是会自动帮我们吧cookie带上传给服务器端的。这样在每次请求的时候通过cookie获取session id,然后通过它在服务端获取登录信息即可完成用户权限的校验。本来这也是个不错的功能，但是由于cookie实在是太开放了，如果一个用户在A网站登录了，并且在没有登出的情况下（没有清楚本地信息，包括cookie），用户在B网站访问的时候发送了一个A网站的请求，那么这个请求其实带有这个用户在A网站的登录信息的。如果这时候B网站发送的A网站请求是用户不知道的，并且可以进行用户非本意操作（获取信息，修改内容，转账等）。那就是非常严重的危害了。以上的过程就是跨站请求攻击，即Cross-Site Request Forgery，即CSRF。</li>
</ul>
<h3 id="CSRF的危害"><a href="#CSRF的危害" class="headerlink" title="CSRF的危害"></a>CSRF的危害</h3><ul>
<li>简单总结CSRF漏洞就是利用网站权限校验方面的漏洞在用户不知觉的情况下发送请求，达到’伪装’用户的目的。攻击者利用CSRF实现的攻击主要有以下几种：<ul>
<li>攻击着能够欺骗受害用户完成该受害者所允许的任一状态改变的操作，比如：更新账号细节，完成购物，注销甚至登录等操作</li>
<li>获取用户的隐私数据</li>
<li>配合其它漏洞攻击</li>
<li>CSRF蠕虫</li>
</ul>
</li>
<li>关于CSRF蠕虫的解释：就是指产生蠕虫效果，会将CSRF攻击一传十，十传百。如：某社区私信好友的接口和获取好友列表的接口都存在CSRF漏洞，攻击者就可以将其组合成一个CSRF蠕虫，当一个用户访问恶意页面后通过CSRF获取其好友列表信息，然后再利用私信好友的CSRF漏洞给其每个好友发送一条指向恶意页面的信息，只要有人查看这个信息里的链接，CSRF蠕虫就会不断传播下去，其可能造成的危害和影响非常巨大。</li>
<li>从本质上讲，CSRF漏洞就是黑客将一个http接口中需要传递的所有参数预测出来，然后不管用什么方式，他都可以根据他的目的来任意调用你的接口，对服务器实现CURD操作，就是对服务器中的数据进行增删改查。</li>
</ul>
<h3 id="如何防范CSRF攻击"><a href="#如何防范CSRF攻击" class="headerlink" title="如何防范CSRF攻击"></a>如何防范CSRF攻击</h3><ul>
<li>观察CSRF的两个特点：利用<strong>cookie自动携带</strong>的特性和<strong>跨站攻击</strong>。那么可以针对这两个特性去针对，找到对应的解决办法</li>
</ul>
<h4 id="检查Referer字段"><a href="#检查Referer字段" class="headerlink" title="检查Referer字段"></a>检查Referer字段</h4><ul>
<li>HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。通过在网站中校验请求的该字段，我们能知道请求是否从本站触发的。我们可以拒绝一切非本站发出的请求，这样避免了CSRF的跨站特性。</li>
<li>这种方式利用了客户端无法构造Referer的特性，虽然简单，不过当网站域名有多个，或者经常变换域名的时候会变得非常的麻烦，同时也具有一定的局限性。</li>
</ul>
<h4 id="Token验证"><a href="#Token验证" class="headerlink" title="Token验证"></a>Token验证</h4><ul>
<li>由于CSRF是利用了浏览器自动传递cookie的特性，另外一个防御思路就是校验信息不能通过cookie传递，在其它参数中增加随机加密串进行校验。为每一个提交增加一个指定串参数，该参数服务器端通过页面下发，放到localStorage中，每次请求的时候补充到提交参数中，服务端通过校验该参数是否一致来判断是否是用户请求。由于CSRF攻击中攻击者是无从事先得知该字符串，所以服务器就可以通过校验该值拒绝可以请求。</li>
</ul>
]]></content>
      <categories>
        <category>网络与安全</category>
      </categories>
      <tags>
        <tag>网络与安全</tag>
      </tags>
  </entry>
  <entry>
    <title>网络与安全-关于XSS攻击</title>
    <url>/2020/08/01/%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/%E5%85%B3%E4%BA%8EXSS%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<blockquote>
<p>网络千万条，安全第一条，网安不规范，网站都完蛋</p>
</blockquote>
<a id="more"></a>

<h3 id="什么是XSS攻击"><a href="#什么是XSS攻击" class="headerlink" title="什么是XSS攻击"></a>什么是XSS攻击</h3><ul>
<li>XSS攻击指的是：<strong>通过利用网页开发时留下得漏洞，恶意攻击者往Web页面里面插入恶意Script代码，当用户浏览时，嵌入其中Web里面得Script代码会被执行，从而达到恶意攻击用户得目的。</strong></li>
<li>XSS全称是：<strong>跨站脚本攻击（Cross Site Script）</strong>。为嘛不叫CSS，因为和层叠样式表CSS冲突了，所以取名XSS。</li>
<li>由于现代浏览器的”同源策略”已经让运行再浏览器中的javascipt代码很难对外站进行访问了，所以，这个漏洞的名称可能存在一定的误导性，随着Web的迅速发展，现在JavaScript通吃前后端，甚至还可以开发APP，所以在产生的应用场景越来越多，越来越复杂的情况下，XSS愈来愈难统一针对，现在业内达成的共识就是，针对不同的场景而产生不同的XSS，需要区分对待。</li>
</ul>
<h3 id="XSS攻击带来的危害"><a href="#XSS攻击带来的危害" class="headerlink" title="XSS攻击带来的危害"></a>XSS攻击带来的危害</h3><ul>
<li>通过document.cookie，盗取cookie中的信息</li>
<li>使用js或css破坏页面正常的结构与样式</li>
<li>流量劫持（通过访问某段具有window.location.href定位到其它页面）</li>
<li>dos攻击：利用合理的客户端请求来占用过多的服务器资源，从而使合法用户无法得到服务器响应。并且通过携带过程的cookie信息可以使服务器返回400开头的状态码，从而拒绝合理的请求服务。</li>
<li>利用iframe,frame,XMLHttpRequest或Flash等方式，以（被攻击者）用户的身份执行一些管理动作，或者执行一些一般如发微博，加好友，发私信等操作，并且攻击者还可以利用iframe,frame进一步的进行CSRF攻击</li>
<li>控制企业数据，包括读取，篡改，添加，删除企业敏感数据的能力。</li>
</ul>
<h3 id="XSS攻击分类"><a href="#XSS攻击分类" class="headerlink" title="XSS攻击分类"></a>XSS攻击分类</h3><ul>
<li>反射性XSS攻击（非持久性XSS）、存储型XSS攻击（持久性XSS攻击）。</li>
</ul>
<h4 id="1-存储型XSS攻击"><a href="#1-存储型XSS攻击" class="headerlink" title="1. 存储型XSS攻击"></a>1. 存储型XSS攻击</h4><ul>
<li>攻击流程：攻击者事先将恶意代码上传或者存储到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码，这就意味着只要访问了这个页面的访客，都有可能会执行这段恶意代码脚本，因此存储型XSS的危害会更大。</li>
<li>攻击方向：存储型XSS一般出现在网站留言，评论，博客日志等交互处，恶意脚本存储到客户端或者服务器的数据库中，<strong>存储型XSS攻击更多时候用于攻击用户，而且在工作中的防范更多是防范存储型XSS攻击</strong>。</li>
<li>攻击模拟</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 首先，攻击者向一个textarea输入一下内容</span></span><br><span class="line">&lt;script&gt; getData(<span class="built_in">document</span>.cookie)&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 2. 然后，前端调用ajax向后端</span></span><br><span class="line"><span class="regexp">$('send').click(function () &#123;</span></span><br><span class="line"><span class="regexp">    $.post('message.html', &#123;'msg': $('textarea').value()&#125;, function() &#123;&#125;);</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 3. 接着，后端接受值写入数据库，同时又返回给前端展示。</span></span><br><span class="line"><span class="regexp">applicationCache.post('message.html', function (req, res, next) &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 写入数据</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ ...</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 响应前端</span></span><br><span class="line"><span class="regexp">    res.json(&#123;</span></span><br><span class="line"><span class="regexp">        rest: req.body.msg</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 4. 最后，新用户访问的时候，会读取数据库，并返回注入的恶意代码的网站，用于获取用户的信息，将用户信息返回给攻击者</span></span><br></pre></td></tr></table></figure>

<h4 id="2-反射型XSS攻击"><a href="#2-反射型XSS攻击" class="headerlink" title="2. 反射型XSS攻击"></a>2. 反射型XSS攻击</h4><ul>
<li>攻击手段：反射性XSS一般是通过特定手法（如电子邮箱），诱使用户去访问一个包含恶意代码的URL，当受害者点击这些专门设计的链接时候，恶意代码会直接在受害者主机上的浏览器执行。</li>
<li>对于访问者而言是一次性的，<strong>具有表现在我们的恶意脚本通过URL的方式传递给了服务器，而服务器则只是不加处理的把脚本“反射”回访者的浏览器而使访问者的浏览器执行相应的脚本。</strong></li>
<li>反射型XSS的触发有后端的参与，<strong>要避免反射型XSS，必须需要后端的协调，后端解析前端的数据时首先做相关的字符串检测和转义处理。</strong></li>
<li><strong>此类XSS通常出现在网站的搜索栏，用户登录口等地方，常用来窃取客户端Cookies或进行钓鱼欺骗</strong>。</li>
<li>对于反射型XSS攻击，还有一种单纯发生在客户端XSSl攻击，也称为DOM-XSS,当用户在当前的页面自己输入具有问题的代码，会导致页面被恶意注入，但是不会影响到服务器。</li>
<li>反射型攻击模拟</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前提：目标网站存在XSS攻击漏洞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 攻击者诱导用户点击具有XSS攻击代码的目标网站链接</span></span><br><span class="line"><span class="comment">// http://www.test.com?kw=&lt;script&gt;document.cookie&lt;/script&gt;, 假设test.com是一个搜索网站</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 目标网站的服务器收到相应的链接，不做安全处理（问题就出现在这里），处理完正常的业务逻辑，将搜索内容返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 当搜索内容返回后，在用户端进行展示。并执行XSS攻击代码（获取用户cookie等操作）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 攻击者通过向目标网站注入代码，代码客户端执行，并返回客户端的信息完成一次XSS攻击</span></span><br></pre></td></tr></table></figure>

<h3 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h3><h4 id="1-XSS防御之HTML编码"><a href="#1-XSS防御之HTML编码" class="headerlink" title="1. XSS防御之HTML编码"></a>1. XSS防御之HTML编码</h4><ul>
<li>应用范围：将不可信数据放入到HTML标签内（例如div,span等）的时候进行HTML编码。</li>
<li>编码规则：将$ &lt; &gt; “ ‘ / 等转义为实体字符（十进制、十六进制）</li>
<li>示例：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeForHtml</span>(<span class="params">str, kwargs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">''</span> + str)</span><br><span class="line">        .replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">        .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">        .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>)</span><br><span class="line">        .replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#x27;'</span>)</span><br><span class="line">        .replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quot;'</span>)</span><br><span class="line">        .replace(<span class="regexp">/\//g</span>, <span class="string">'&amp;#x2f;'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-XSS防御之HTML-Attribute编码"><a href="#2-XSS防御之HTML-Attribute编码" class="headerlink" title="2. XSS防御之HTML Attribute编码"></a>2. XSS防御之HTML Attribute编码</h4><ul>
<li>应用范围：将不可信数据放入HTML属性时（不含src,href,style和事件处理属性），进行HTML Attribute编码</li>
<li>编码规则：除了字母数字字符以外，使用&#xHH;(或者可用的命名实体)格式来转义ASCII值小于256所有的字符</li>
<li>示例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeForHTMLAttribute</span>(<span class="params">str, kwargs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> encoded = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> ch = str[i];</span><br><span class="line">        <span class="keyword">let</span> hex = str[i];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="regexp">/[A-Za-z0-9]/</span>.test(str[i]) &amp;&amp; str.charCodeAt(i) &lt; <span class="number">256</span>) &#123;</span><br><span class="line">            hex = <span class="string">'&amp;#x'</span> + ch.charCodeAt(<span class="number">0</span>).toString(<span class="number">16</span>) + <span class="string">';'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        encoded += hex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> encoded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-XSS防御之JavaScript编码"><a href="#3-XSS防御之JavaScript编码" class="headerlink" title="3. XSS防御之JavaScript编码"></a>3. XSS防御之JavaScript编码</h4><ul>
<li>作用范围：将不可信数据放入事件处理属性、JavaScript值时进行JavaScript编码</li>
<li>编码规则：除了字母数字字符外，使用\xHH格式进行转义ASCII码小于256的所有字符</li>
<li>示例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeForJavaScript</span>(<span class="params">str, kwargs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> encoded = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> cc = str[i];</span><br><span class="line">        <span class="keyword">let</span> hex = str[i];</span><br><span class="line">        <span class="keyword">if</span> (!<span class="regexp">/[A-Za-z0-9]/</span>.test(str[i]) &amp;&amp; str.charCodeAt(i) &lt; <span class="number">256</span>) &#123;</span><br><span class="line">            hex = <span class="string">'\\x'</span> + cc.charCodeAt().toString(<span class="number">16</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        encoded += hex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> encoded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-XSS防御之URL编码"><a href="#4-XSS防御之URL编码" class="headerlink" title="4. XSS防御之URL编码"></a>4. XSS防御之URL编码</h4><ul>
<li>作用范围：将不可信数据作为URL参数值时需要对参数进行URL编码</li>
<li>编码规则：将参数值进行encodeURIComponent编码</li>
<li>示例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeForURL</span>(<span class="params">str, kwargs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">encodeURIComponent</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-XSS防御之CSS编码"><a href="#5-XSS防御之CSS编码" class="headerlink" title="5. XSS防御之CSS编码"></a>5. XSS防御之CSS编码</h4><ul>
<li>作用范围：将不可信数据作为CSS进行CSS编码</li>
<li>编码规则：除了字母数字字符之外，使用\XXXXXX格式来转义ASCII值小于256的所有字符。</li>
<li>示例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeForCSS</span>(<span class="params">attr, str, kwargs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> encoded = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> ch = str.charCodeAt(i);</span><br><span class="line">        <span class="keyword">if</span> (!ch.match(<span class="regexp">/[A-Za-z0-9]/</span>)) &#123;</span><br><span class="line">            <span class="keyword">let</span> hex = str.charCodeAt(i).toString(<span class="number">16</span>);</span><br><span class="line">            <span class="keyword">let</span> pad = <span class="string">'000000'</span>.substr((hex.length));</span><br><span class="line">            encode += <span class="string">'\\'</span> + pad + hex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            encoded += ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> encoded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>任何时候用户的输入都是不可信的。对于http参数，理论上都要进行验证，例如某个字段是枚举类型，其就不应该出现枚举以为的值；对于不可信数据的输出进行相应的编码。</li>
<li>XSS漏洞有时比较难发现，所幸当下React,Vue等框架都从框架层面引入了XSS防御机制，一定程度上解放了我们的双手，框架是辅助，我们仍需以人为本，规范开发习惯，提高 Web 前端安全意识。</li>
</ul>
]]></content>
      <categories>
        <category>网络与安全</category>
      </categories>
      <tags>
        <tag>网络与安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Es6-对Promise的理解</title>
    <url>/2020/07/30/Es6/%E5%AF%B9Promise%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>需要解决的问题 </li>
<li>ES6异步处理的通用模型</li>
<li>Promise API详细梳理</li>
</ul>
</blockquote>
<a id="more"></a>

<h3 id="ES6之前异步处理的几个问题"><a href="#ES6之前异步处理的几个问题" class="headerlink" title="ES6之前异步处理的几个问题"></a>ES6之前异步处理的几个问题</h3><blockquote>
<ol>
<li>回调配合着嵌套会产生回调地狱问题，思路很不清晰，迭代会非常麻烦</li>
<li>由于回调存在着依赖反装，在使用第三方提供的方法时，会产生信任问题</li>
<li>当我们不写错误的回调函数时，会存在异常无法捕获</li>
<li>导致性能更差，本来可以一起做的但是使用回调，导致多件事情顺序执行，用的时间更多</li>
</ol>
</blockquote>
<h3 id="异步处理的通用模型"><a href="#异步处理的通用模型" class="headerlink" title="异步处理的通用模型"></a>异步处理的通用模型</h3><blockquote>
<p>两个阶段 三种状态  不可逆 后续处理 </p>
</blockquote>
<blockquote>
<ol>
<li><p>ES6 将某一件可能发生异步操作的事情，分为两个阶段：<strong><em>\</em>unsettled**</strong> 和 <strong><em>\</em>settled**</strong></p>
<ul>
<li><p>unsettled： 未决阶段，表示事情还在进行前期的处理，并没有发生通向结果的那件事</p>
</li>
<li><p>settled：已决阶段，事情已经有了一个结果，不管这个结果是好是坏，整件事情无法逆转</p>
</li>
</ul>
<p>事情总是从 未决阶段 逐步发展到 已决阶段的。并且，未决阶段拥有控制何时通向已决阶段的能力。</p>
</li>
<li><p>ES6将事情划分为三种状态： pending、resolved、rejected</p>
<ul>
<li><p>pending: 挂起，处于未决阶段，则表示这件事情还在挂起（最终的结果还没出来）</p>
</li>
<li><p>resolved：已处理，已决阶段的一种状态，表示整件事情已经出现结果，并是一个可以按照正常逻辑进行下去的结果</p>
</li>
<li><p>rejected：已拒绝，已决阶段的一种状态，表示整件事情已经出现结果，并是一个无法按照正常逻辑进行下去的结果，通常用于表示有一个错误</p>
</li>
<li><p>既然未决阶段有权力决定事情的走向，因此，未决阶段可以决定事情最终的状态！</p>
</li>
</ul>
<p>我们将 把事情变为resolved状态的过程叫做：<strong><em>\</em>resolve**</strong>，推向该状态时，可能会传递一些数据</p>
<p>我们将 把事情变为rejected状态的过程叫做：<strong><em>\</em>reject**</strong>，推向该状态时，同样可能会传递一些数据，通常为错误信息</p>
<p><strong><em>\</em>始终记住，无论是阶段，还是状态，是不可逆的！**</strong></p>
</li>
<li><p>当事情达到已决阶段后，通常需要进行后续处理，不同的已决状态，决定了不同的后续处理。</p>
<ul>
<li><p>resolved状态：这是一个正常的已决状态，后续处理表示为 thenable</p>
</li>
<li><p>rejected状态：这是一个非正常的已决状态，后续处理表示为 catchable</p>
</li>
</ul>
<p>后续处理可能有多个，因此会形成作业队列，这些后续处理会按照顺序，当状态到达后依次执行</p>
</li>
<li><p>整件事称之为Promise</p>
</li>
</ol>
</blockquote>
<h3 id="Promise-API详解"><a href="#Promise-API详解" class="headerlink" title="Promise API详解"></a>Promise API详解</h3><h4 id="1-创建Promise实例"><a href="#1-创建Promise实例" class="headerlink" title="1. 创建Promise实例"></a>1. 创建Promise实例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pro = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 未决阶段的处理</span></span><br><span class="line">    <span class="comment">// 通过调用resolve函数将Promise推向已决阶段的resolved状态</span></span><br><span class="line">    <span class="comment">// 通过调用reject函数将Promise推向已决阶段的rejected状态</span></span><br><span class="line">    <span class="comment">// resolve和reject均可以传递最多一个参数，表示推向状态的数据</span></span><br><span class="line">&#125;)</span><br><span class="line">pro.then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//这是thenable函数，如果当前的Promise已经是resolved状态，该函数会立即执行</span></span><br><span class="line">    <span class="comment">//如果当前是未决阶段，则会加入到作业队列，等待到达resolved状态后执行</span></span><br><span class="line">    <span class="comment">//data为状态数据</span></span><br><span class="line">&#125;, err=&gt;&#123;</span><br><span class="line">    <span class="comment">//这是catchable函数，如果当前的Promise已经是rejected状态，该函数会立即执行</span></span><br><span class="line">    <span class="comment">//如果当前是未决阶段，则会加入到作业队列，等待到达rejected状态后执行</span></span><br><span class="line">    <span class="comment">//err为状态数据</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>未决阶段的处理函数是同步的，会立即执行</li>
<li>thenable和catchable函数是异步的，就算是立即执行，也会加入到事件队列中等待执行，并且，加入的队列是微队列</li>
<li>pro.then可以只添加thenable函数，pro.catch可以单独添加catchable函数</li>
<li>在未决阶段的处理函数中，如果发生未捕获的错误，会将状态推向rejected，并会被catchable捕获</li>
<li>一旦状态推向了已决阶段，无法再对状态做任何更改</li>
<li><strong>Promise并没有消除回调，只是让回调变得可控</strong></li>
</ol>
</blockquote>
<h4 id="2-Promise的串联"><a href="#2-Promise的串联" class="headerlink" title="2. Promise的串联"></a>2. Promise的串联</h4><blockquote>
<p>当后续的Promise需要用到之前的Promise的处理结果时 ，需要Promise的串联</p>
<p>Promise对象中，无论是then方法还是catch方法，它们都具有返回值，返回的是一个全新的Promise对象，它的状态满足下面的规则：</p>
<pre><code>1. 如果当前的Promise是未决的，得到的新的Promise是挂起状态
2. 如果当前的Promise是已决的，会运行响应的后续处理函数，并将后续处理函数的结果（返回值）作为resolveed状态数据，应用到新的Promise中；如果后续处理函数发生错误，则把返回值作为rejected状态数据，应用到新的Promise中。</code></pre><p><strong>后续的Promise一定会等到前面的Promise有了后续处理结果后，才会变成已决状态</strong></p>
<p>如果前面的Promise的后续处理，返回的是一个Promise，则返回的新的Promise状态和后续返回的Promise状态保持一致。</p>
</blockquote>
<h4 id="3-Promise-prototype-then"><a href="#3-Promise-prototype-then" class="headerlink" title="3. Promise.prototype.then()"></a>3. Promise.prototype.then()</h4><blockquote>
<p>作用：为Promise实例添加状态改变时的回调函数，then方法的第一个参数是Resolved状态的回调函数，第二参数（可选）是Rejected状态的回调函数</p>
<p>then方法返回的是一个新的Promise实例，会将then方法的返回值作为参数传入后续的回调函数中，如果传递的是一个Promise对象（即有异步操作），而后一个回调函数就会等待该Promise对象的状态发生变化，再被调用。</p>
</blockquote>
<h4 id="4-Promise-prototype-catch"><a href="#4-Promise-prototype-catch" class="headerlink" title="4. Promise.prototype.catch()"></a>4. Promise.prototype.catch()</h4><blockquote>
<p>作用：用于指定发生错误时的回调函数。</p>
<p>注意：</p>
<pre><code>1. Promise对象的错误具有&quot;冒泡&quot;性质，会一直向后传递，直到被捕获为止，也就是说，错误总会被下一个catch语句捕获
2. catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法</code></pre></blockquote>
<h4 id="5-Promise-all"><a href="#5-Promise-all" class="headerlink" title="5. Promise.all()"></a>5. Promise.all()</h4><blockquote>
<p>作用：Promise.all方法用于将多个Promise实例包装成一个新的Promise实例，【有错误处理错误，没错误返回全部】</p>
<ul>
<li>Promise.all()的方法参数不一定是数组，但是必须具有Iterator接口，且返回的每个成员都是Promise实例；</li>
<li>只有参数中的状态都变成的Fulfilled，Promise.all()的状态才会变成Fulfilled，会把每个参数的返回值封装到一个数组中，传递给后续的回调函数中作为参数；</li>
<li>如果参数中的状态有一个为Rejected，则会把第一个为Rejected状态的返回值作为参数传递给后续的回调函数；</li>
<li>如果作为参数的Promise实例自身定义了catch方法，那么它被rejected时并不会触发Promise.all()的catch方法</li>
<li>如果参数中是非Promise实例，会先调用Promise.resolve()进行包装，并返回一个Promise实例</li>
</ul>
</blockquote>
<h4 id="6-Promise-race"><a href="#6-Promise-race" class="headerlink" title="6. Promise.race()"></a>6. Promise.race()</h4><blockquote>
<p>作用：将多个Promise实例包装成一个新的Promise实例，【处理第一个改变状态的实例】</p>
<ul>
<li>Promise.race方法的参数与Promise.all方法一样，如果不是Promise实例，就会先调用Promise.resolve方法，将参数传递给Promise实例，再进一步处理。</li>
</ul>
</blockquote>
<h4 id="7-Promise-resolve"><a href="#7-Promise-resolve" class="headerlink" title="7. Promise.resolve()"></a>7. Promise.resolve()</h4><blockquote>
<p>作用：将现有对象转为Promise对象</p>
<p>几种参数不同的情况：</p>
<ul>
<li>参数是一个Promise实例<ul>
<li>如果参数是Promise实例，那么Promise.resolve将不做任何修改，原则不动地返回这个实例。</li>
</ul>
</li>
<li>参数是一个thenable对象<ul>
<li>thenable对象值得是具有then方法的对象</li>
<li>Promise.resolve方法会将这个对象转为Promise对象，然后立即执行thenable对象的then方法</li>
</ul>
</li>
<li>参数不是具有then方法的对象或者根本不是对象<ul>
<li>如果参数是一个原始值，或者是一个不具有then方法的对象，那么Promise。resolve方法返回一个新的Promise对象，状态为resolved</li>
</ul>
</li>
<li>不带有任何参数<ul>
<li>直接返回一个Resolved状态的Promise对象</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="8-Promise-reject"><a href="#8-Promise-reject" class="headerlink" title="8. Promise.reject()"></a>8. Promise.reject()</h4><blockquote>
<p>作用：Promise.reject(reason)方法也会返回一个新的Promise实例，状态为Rejected</p>
<p>注意：</p>
<ul>
<li>Promise.reject()方法的参数会原封不动地作为reject的理由变成后续方法的参数，这一点与Promise.resolve方法不一样。</li>
</ul>
</blockquote>
<h4 id="9-实现done"><a href="#9-实现done" class="headerlink" title="9. 实现done()"></a>9. 实现done()</h4><blockquote>
<p>作用：安全的捕获错误</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.then(onFulfilled, onRejected)</span><br><span class="line">        .catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 抛出一个全局错误</span></span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;, <span class="number">0</span>) <span class="comment">// 放到宏队列中执行</span></span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-实现finally"><a href="#10-实现finally" class="headerlink" title="10. 实现finally()"></a>10. 实现finally()</h4><blockquote>
<p>作用：finally方法用于指定Promise对象最后状态如何都会执行的操作。他与done方法的最大区别在于，让接受一个普通的回调函数作为参数，该函数不管怎么样都必须执行。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> P = <span class="keyword">this</span>.constructor;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">        value =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">        reason =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Es6</category>
      </categories>
      <tags>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title>Es6-利用Proxy实现数组读取负数索引</title>
    <url>/2020/07/28/Es6/%E5%88%A9%E7%94%A8Proxy%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E8%AF%BB%E5%8F%96%E8%B4%9F%E6%95%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<blockquote>
<p>Proxy: 可以修改某些操作的默认行为，等同于在语言层面上做出修改，所以属于一种’元编程’, 即对编程语言进行编程</p>
</blockquote>
<a id="more"></a>

<h3 id="使用get拦截实现数组读取负数索引"><a href="#使用get拦截实现数组读取负数索引" class="headerlink" title="使用get拦截实现数组读取负数索引"></a>使用get拦截实现数组读取负数索引</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">...elements</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> handler = &#123;</span><br><span class="line">        <span class="keyword">get</span>: function (target, propKey, receiver) &#123;</span><br><span class="line">            <span class="keyword">let</span> index = <span class="built_in">Number</span>(propKey);</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123; <span class="comment">// 判断是否小于0</span></span><br><span class="line">                propKey = <span class="built_in">String</span>(target.length + index);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, propKey, receiver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> target = [];</span><br><span class="line">    target.push(...elements);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = createArray(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">-1</span>]); <span class="comment">// c</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Es6</category>
      </categories>
      <tags>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title>Es6-利用getOwnPropertyDescriptors()实现Mixin模式</title>
    <url>/2020/07/27/Es6/%E5%AE%9E%E7%8E%B0Mixin(%E6%B7%B7%E5%85%A5)%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>Mixin模式：混入模式（浅克隆）</p>
</blockquote>
<a id="more"></a>

<h3 id="利用getOwnPropertyDescriptors-实现"><a href="#利用getOwnPropertyDescriptors-实现" class="headerlink" title="利用getOwnPropertyDescriptors()实现"></a>利用getOwnPropertyDescriptors()实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mix = <span class="function">(<span class="params">object</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="keyword">with</span>: <span class="function">(<span class="params">...mixins</span>) =&gt;</span> mixins.reduce(<span class="function">(<span class="params">c, mixin</span>) =&gt;</span> <span class="built_in">Object</span>.create( <span class="comment">// 循环复制操作mixins中的对象</span></span><br><span class="line">        c,</span><br><span class="line">        <span class="built_in">Object</span>.getOwnPropertyDescriptors(mixin)</span><br><span class="line">    ), object)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">a</span>: <span class="string">'1'</span>, <span class="attr">n</span>: <span class="string">'4'</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123; <span class="attr">b</span>: <span class="string">'2'</span>, <span class="attr">n</span>: <span class="string">'5'</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> c = &#123; <span class="attr">c</span>: <span class="string">'3'</span>, <span class="attr">n</span>: <span class="string">'6'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = mix(a).with(b, c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> d) &#123; <span class="comment">// for in循环会读取原型上的属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">':'</span> + d[key]); <span class="comment">// c:3 n:6 b:2 a:1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Es6</category>
      </categories>
      <tags>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title>Es6-实现Object.getOwnPropertyDescriptors()</title>
    <url>/2020/07/26/Es6/%E5%AE%9E%E7%8E%B0getOwnPropertyDescriptors()/</url>
    <content><![CDATA[<blockquote>
<p>Object.getOwnPropertyDescriptors(): 返回莫格对象属性的描述对象</p>
</blockquote>
<a id="more"></a>

<h3 id="利用getOwnPropertyDescriptor-实现"><a href="#利用getOwnPropertyDescriptor-实现" class="headerlink" title="利用getOwnPropertyDescriptor()实现"></a>利用getOwnPropertyDescriptor()实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOwnPropertyDescriptors</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(obj)) &#123;</span><br><span class="line">        result[key] = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span>, <span class="attr">q</span>: <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> decs = getOwnPropertyDescriptors(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(decs);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     p: &#123; value: 1, writable: true, enumerable: true, configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//     q: &#123; value: 2, writable: true, enumerable: true, configurable: true &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Es6</category>
      </categories>
      <tags>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title>Es6-实现__proto__</title>
    <url>/2020/07/25/Es6/%E5%AE%9E%E7%8E%B0__proto__/</url>
    <content><![CDATA[<blockquote>
<p>__ proto __:  用来读取或者设置当前对象的prototype对象</p>
</blockquote>
<a id="more"></a>

<h3 id="利用getPrototypeOf和setPrototypeOf实现"><a href="#利用getPrototypeOf和setPrototypeOf实现" class="headerlink" title="利用getPrototypeOf和setPrototypeOf实现"></a>利用getPrototypeOf和setPrototypeOf实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'__proto__'</span>, &#123;</span><br><span class="line">    <span class="comment">// 读操作</span></span><br><span class="line">    <span class="keyword">get</span> () &#123;</span><br><span class="line">        <span class="keyword">let</span> _thisObj = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(_thisObj);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写操作</span></span><br><span class="line">    <span class="keyword">set</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">undefined</span> &amp;&amp; <span class="keyword">this</span> == <span class="literal">null</span>) &#123; <span class="comment">// 判断this是否为空</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isObject(<span class="keyword">this</span>)) &#123; <span class="comment">// 判断this是否为对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isObject(proto)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> status = <span class="built_in">Reflect</span>.setPrototypeOf(<span class="keyword">this</span>, proto);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!status) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>(value) === value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Es6</category>
      </categories>
      <tags>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title>Es6-实现Object.entries</title>
    <url>/2020/07/24/Es6/%E5%AE%9E%E7%8E%B0Object.entries/</url>
    <content><![CDATA[<blockquote>
<p>Object.entries: 返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的<strong>键值对数组</strong></p>
</blockquote>
<a id="more"></a>

<h3 id="Generator函数的版本"><a href="#Generator函数的版本" class="headerlink" title="Generator函数的版本"></a>Generator函数的版本</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Generator函数的版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">entries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">        <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="非Generator函数的版本"><a href="#非Generator函数的版本" class="headerlink" title="非Generator函数的版本"></a>非Generator函数的版本</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非Generator函数版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">entires</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">        arr.push([key, obj[key]])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Es6</category>
      </categories>
      <tags>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title>Js基础-防抖与节流的实现</title>
    <url>/2020/07/23/Js%E5%9F%BA%E7%A1%80/8.Js%E5%9F%BA%E7%A1%80-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h3 id="防抖-amp-节流"><a href="#防抖-amp-节流" class="headerlink" title="防抖&amp;节流"></a>防抖&amp;节流</h3><p>在前端开发中有一部分的用户行为会频繁的触发事件执行，而对于DOM操作、资源加载等耗费性能的处理，很可能导致界面卡顿，甚至浏览器的崩溃。函数节流（throttle)和函数防抖（debounce)就是为了解决类似需求应运而生的。</p>
<a id="more"></a>

<h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><ul>
<li><p>函数防抖就是在函数需要频繁触发情况时，只有足够空闲的时间，才执行一次。好像公交司机会等人都上车后才出站一样。</p>
</li>
<li><p>场景</p>
<ul>
<li><p>实时搜索（keyup)</p>
</li>
<li><p>拖拽（mousemove)</p>
</li>
</ul>
</li>
<li><p>代码模拟</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">'inp'</span> &gt;</span> <span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> oInp = <span class="built_in">document</span>.getElementById(<span class="string">'inp'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript"><span class="comment">//handler:哪个元素需要防抖，delay:防抖的时间</span></span></span><br><span class="line"><span class="actionscript"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> <span class="params">(handler, delay)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> timer = <span class="literal">null</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> _self = <span class="keyword">this</span>, _arg = <span class="built_in">arguments</span>;</span></span><br><span class="line">        clearTimeout(timer);</span><br><span class="line"><span class="actionscript">        timer = setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">            handler.apply(_self, _arg);</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">oInp.onInput = debounce(ajax, 2000);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><ul>
<li><p>函数节流就是预定一个函数只有在大于等于执行周期时才执行，周期内调用不执行。好像水滴攒到一定重量才回落下一样</p>
</li>
<li><p>场景</p>
<ul>
<li><p>窗口调整（resize）</p>
</li>
<li><p>页面滚动 (scroll)</p>
</li>
<li><p>抢购疯狂点击（mousedown)</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'show'</span>&gt;</span>0<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">'btn'</span>&gt;</span> click <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">'show'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oBtn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span></span><br><span class="line">    </span><br><span class="line"><span class="actionscript">    <span class="comment">// handle: 需要节流的函数 wait: s时间</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">throttle</span> <span class="params">(handler, wait)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> nowTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span></span><br><span class="line">            if (nowTime - lastTime &gt; wait) &#123;</span><br><span class="line"><span class="javascript">            	handler.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span></span><br><span class="line">            	lastTime = nowTime;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        oDiv.innerText = <span class="built_in">parseInt</span>(oDiv.innerText) + <span class="number">1</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    oBtn.onclick = throttle(buy, 1000);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Js基础</category>
      </categories>
      <tags>
        <tag>Js基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Js基础-手撕bind()源码</title>
    <url>/2020/07/22/Js%E5%9F%BA%E7%A1%80/7.Js%E5%9F%BA%E7%A1%80-%E6%89%8B%E6%92%95bind/</url>
    <content><![CDATA[<h3 id="bind方法解读"><a href="#bind方法解读" class="headerlink" title="bind方法解读"></a>bind方法解读</h3><ul>
<li>函数A调用bind方法时，需要传递的参数o, x,  y, z….</li>
<li>返回新的函数B</li>
<li>函数B在执行的时候，具体的功能实际上还是使用A,只不过this指向变成o</li>
<li>函数B在执行的时候，传递的参数会拼接到x, y, z后面，一并在内部传给A执行</li>
<li>new B() 构成函数依旧是A, 而且o不会起到任何作用</li>
</ul>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y, z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> z = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> B = A.bind(o, x, y);</span><br><span class="line">B(<span class="string">'c'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="newBind方法的实现"><a href="#newBind方法的实现" class="headerlink" title="newBind方法的实现"></a>newBind方法的实现</h3><ul>
<li>怎么做到参数拼接？<ul>
<li>在返回的函数中进行参数拼接</li>
</ul>
</li>
<li>怎么做到this传递？<ul>
<li>用apply</li>
</ul>
</li>
<li>怎么做到原型继承而不会原函数的原型<ul>
<li>用中介函数</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.newBind = <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// this指向</span></span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>); <span class="comment">// 拿到参数</span></span><br><span class="line">    <span class="keyword">var</span> temp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line">    <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _arg = [].slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>); <span class="comment">// 拿到后面传进来的参数</span></span><br><span class="line">        <span class="comment">// self就是上面this的执行，也就是谁调用了newBind， this就指向谁</span></span><br><span class="line">        <span class="comment">// 参数1：三目运算：判断调用self的时候this的指向，判断this的原型链上是否存在temp的原型</span></span><br><span class="line">        <span class="comment">// 参数2：拼接的参数</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> temp ? <span class="keyword">this</span> : (target || <span class="built_in">window</span>), args.concat(_arg));</span><br><span class="line">    &#125;</span><br><span class="line">    temp.prototype = self.prototype; <span class="comment">// 把temp的原型指向成self的原型</span></span><br><span class="line"></span><br><span class="line">    f.prototype = <span class="keyword">new</span> temp(); <span class="comment">// 把f的原型指向temp函数返回的对象上，因为temp函数的原型指向self的原型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Js基础</category>
      </categories>
      <tags>
        <tag>Js基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Js基础-函数式编程之纯函数和柯里化</title>
    <url>/2020/07/21/Js%E5%9F%BA%E7%A1%80/6.js%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%AF%E5%87%BD%E6%95%B0%E5%92%8C%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<h3 id="函数式编程之纯函数"><a href="#函数式编程之纯函数" class="headerlink" title="函数式编程之纯函数"></a>函数式编程之纯函数</h3><ul>
<li><p>纯函数的定义</p>
<ul>
<li>对于相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用，也不依赖外部环境的状态</li>
<li><strong>纯函数是指不依赖，修改起作用域之外变量的函数</strong></li>
</ul>
</li>
<li><p>Bug-守恒定律</p>
<ul>
<li>一旦网站或应用的代码量达到一定的程度，它将不可避免的包含某种bug。这不是JavaScript特有的问题，而是一个几乎所有语言都有的通病，虽然不是不可能，但是想要彻底清除程序中的所有bug还是非常难办到的。但是，这并不意味着我们不可以通过某些编码方式来预防bug的引入。</li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li>纯函数-作用<ul>
<li>在JavaScript中你可以很容易的创建全局变量，这些变量可以在所有的函数访问到。这也是一个导致bug的常见原因你，因为程序中的任何部分都可能修改全局变量从而导致函数的行为出现异常</li>
<li><strong>纯函数非常容易进行单元测试，因为不需要考虑上下文环境，只需要考虑输入和输出。</strong></li>
<li>纯函数是健壮的，改变执行次序不会对系统造成影响，因此纯函数的操作可以并行执行。</li>
</ul>
</li>
</ul>
<h3 id="函数式编程-柯里化"><a href="#函数式编程-柯里化" class="headerlink" title="函数式编程-柯里化"></a>函数式编程-柯里化</h3><ul>
<li><p>柯里化的含义</p>
<ul>
<li>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术</li>
</ul>
</li>
<li><p>前端为什么柯里化</p>
<ul>
<li>前端使用柯里化的用途主要是简化代码结构，提高系统的维护性，一个方法，只有一个参数，强制了功能的单一性，很自然就做到了功能内聚，降低耦合。</li>
<li>柯里化的优点就是降低代码的反复，提高代码的适应性</li>
</ul>
</li>
<li><p>柯里化的本质</p>
<ul>
<li>期望函数能够传递正确的参数个数，如果没有传递够，则一直期望下去，</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">add</span><span class="params">(a, b, c, d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//柯里化前奏-需要固定数量参数</span></span><br><span class="line"><span class="function">function <span class="title">FixedParmasCurry</span><span class="params">(fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _arg = [].slice.call(arguments, <span class="number">1</span>); <span class="comment">// 第一次传入的参数</span></span><br><span class="line">    console.log(typeof _arg);</span><br><span class="line">    <span class="keyword">return</span> function () &#123;</span><br><span class="line">         <span class="keyword">var</span> newArg = _arg.concat([].slice.call(arguments, <span class="number">0</span>) ); <span class="comment">// 参数拼接</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, newArg); <span class="comment">// 执行函数</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> newAdd = FixedParmasCurry(add, <span class="number">1</span>);</span><br><span class="line">console.log(newAdd(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现柯里化-期待固定数量参数</span></span><br><span class="line"><span class="function">function <span class="title">Curry</span> <span class="params">(fn, length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> length = length || fn.length;</span><br><span class="line">    <span class="keyword">return</span> function () &#123;</span><br><span class="line">        <span class="keyword">if</span> (arguments.length &lt; length) &#123;</span><br><span class="line">            <span class="keyword">var</span> combined = [fn].concat( [].slice.call(arguments, <span class="number">0</span>) ); <span class="comment">// combined = [fn, 1, 2, 3]</span></span><br><span class="line">            <span class="keyword">return</span> Curry(FixedParmasCurry.apply(<span class="keyword">this</span>, combined), length - arguments.length); <span class="comment">// 不满足参数，返回柯里化函数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, arguments); <span class="comment">// 满足，执行函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newAdd = Curry(add);</span><br><span class="line">newAdd(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// newAdd(1)(2, 3)(4);</span></span><br><span class="line"><span class="comment">// newAdd(1, 2)(3)(4);</span></span><br><span class="line"><span class="comment">// newAdd(1, 2)(3, 4);</span></span><br><span class="line"><span class="comment">// newAdd(4)(1, 2, 4);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//柯里化的应用-模拟ajax数据传输，降低代码的反复</span></span><br><span class="line"><span class="comment">//POST www.test1.com 'name=mfx&amp;code=111';</span></span><br><span class="line"><span class="comment">//POST www.test1.com 'key=11';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//POST www.test2.com 'name=mfx&amp;code=111';</span></span><br><span class="line"><span class="comment">//POST www.test2.com 'key=22';</span></span><br><span class="line"><span class="function">function <span class="title">ajax</span> <span class="params">(method, url, data)</span> </span>&#123;</span><br><span class="line">    console.log(method, url, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按照普通的方式</span></span><br><span class="line">ajax(<span class="string">'POST'</span>, <span class="string">'www.test1.com'</span>, <span class="string">'name=mfx&amp;code=111'</span>);</span><br><span class="line">ajax(<span class="string">'POST'</span>, <span class="string">'www.test1.com'</span>, <span class="string">'key=11'</span>);</span><br><span class="line">ajax(<span class="string">'POST'</span>, <span class="string">'www.test2.com'</span>, <span class="string">'name=mfx&amp;code=111'</span>);</span><br><span class="line">ajax(<span class="string">'POST'</span>, <span class="string">'www.test2.com'</span>, <span class="string">'key=22'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//经过柯里化的封装</span></span><br><span class="line"><span class="keyword">var</span> ajaxCurry = Curry(ajax);</span><br><span class="line"><span class="keyword">var</span> PostAjax = ajaxCurry(<span class="string">'POST'</span>);</span><br><span class="line">PostAjax(<span class="string">'www.test1.com'</span>, <span class="string">'name=mfx&amp;code=111'</span>);</span><br><span class="line">PostAjax(<span class="string">'www.test1.com'</span>, <span class="string">'key=11'</span>);</span><br><span class="line">PostAjax(<span class="string">'www.test2.com'</span>, <span class="string">'name=mfx&amp;code=111'</span>);</span><br><span class="line">PostAjax(<span class="string">'www.test2.com'</span>, <span class="string">'key=22'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//再次封装</span></span><br><span class="line"><span class="keyword">var</span> PostTest1Ajax = PostAjax(<span class="string">'www.test1.com'</span>);</span><br><span class="line">PostTest1Ajax(<span class="string">'name=mfx&amp;code=111'</span>);</span><br><span class="line">PostTest1Ajax(<span class="string">'key=11'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> PostTest2Ajax = PostAjax(<span class="string">'www.test2.com'</span>);</span><br><span class="line">PostTest2Ajax(<span class="string">'name=mfx&amp;code=111'</span>);</span><br><span class="line">PostTest2Ajax(<span class="string">'key=22'</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Js基础</category>
      </categories>
      <tags>
        <tag>Js基础</tag>
      </tags>
  </entry>
  <entry>
    <title>ES5中对数组的扩展方法(手撕源码)</title>
    <url>/2020/07/20/Js%E5%9F%BA%E7%A1%80/5.js%E5%9F%BA%E7%A1%80-es5%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95(%E6%89%8B%E6%92%95%E6%BA%90%E7%A0%81)/</url>
    <content><![CDATA[<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>总结forEach;filter;map;some/every/reduce/reduceRight的功能以及对源码的实现</li>
</ul>
<a id="more"></a>

<h3 id="forEach：增强版for循环"><a href="#forEach：增强版for循环" class="headerlink" title="forEach：增强版for循环"></a>forEach：增强版for循环</h3><blockquote>
<p>Array.prototype.forEach(callbackfn(item, index, self), thisArg)</p>
</blockquote>
<ul>
<li>参数解释:<ul>
<li>callbackfn: 回调函数，item: 数组中的元素，index: 元素的索引，self: 数组本身。</li>
<li>thisArg: callbackfn中this的指向，不填的话this指向undefined。</li>
</ul>
</li>
<li>写个例子</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> arr = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>];</span></span><br><span class="line"><span class="actionscript">    arr.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(item, index, self)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 'one' 0 ['one', 'two', ...]</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 'two' 1 ['one', 'two', ...]</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(item, index, self);</span></span><br><span class="line">        </span><br><span class="line"><span class="actionscript">        <span class="comment">// this指向document.getElementsByTagName('li')</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>[index].innerHTML = item;</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>))</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实现myForEach</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Array</span>.prototype.myForEach = <span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> arr = <span class="keyword">this</span>; <span class="comment">// 隐式绑定 -&gt; 绑定的是那个上下文对象（调用方法的数组）</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> len = <span class="keyword">this</span>.length; <span class="comment">// 数组的长度 -&gt; 用于循环</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> param2 = <span class="built_in">arguments</span>[<span class="number">1</span>] || <span class="literal">undefined</span>; <span class="comment">// 获取myForEach第二参数，不存在指向undefined</span></span></span><br><span class="line">        </span><br><span class="line"><span class="actionscript">        <span class="comment">// 用for循环来执行</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 回调函数:func</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// apply:显示绑定this指定的对象</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// param2: 传入的this，如果没有默认undefined</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 传参：item: arr[i], index: i, self: arr</span></span></span><br><span class="line">            func.apply(param2, [arr[i], i, arr])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> arr = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    arr.myForEach(<span class="function"><span class="keyword">function</span> <span class="params">(item, index, self)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 'one' 0 ['one', 'two', ...]</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 'two' 1 ['one', 'two', ...]</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(item, index, self);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>[index].innerHTML = item;</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>))</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="filter-过滤"><a href="#filter-过滤" class="headerlink" title="filter: 过滤"></a>filter: 过滤</h3><blockquote>
<p>Array.prototype.filter(callbackfn(item, index, self), thisArg)</p>
</blockquote>
<ul>
<li>参数解释:<ul>
<li>callbackfn: 回调函数，item: 数组中的元素，index: 元素的索引，self: 数组本身。</li>
<li>thisArg: callbackfn中this的指向，不填的话this指向undefined。</li>
</ul>
</li>
<li>返回return为true的item：会返回一个新数组</li>
<li>写个例子</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> personArr = [</span></span><br><span class="line"><span class="actionscript">        &#123;name: <span class="string">'张三'</span>, sex: <span class="string">'m'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">        &#123;name: <span class="string">'李四'</span>, sex: <span class="string">'m'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">        &#123;name: <span class="string">'刘娜'</span>, sex: <span class="string">'f'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">        &#123;name: <span class="string">'李婷'</span>, sex: <span class="string">'f'</span>&#125;</span></span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> newArray = personArr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, self</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> item.sex == <span class="string">'m'</span>; <span class="comment">// 返回true对应的item</span></span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(newArray); <span class="comment">// [&#123;name: '张三', sex: 'm'&#125;, &#123;name: '李四', sex: 'm'&#125;]</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实现myFilter</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Array</span>.prototype.myFilter = <span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> arr = <span class="keyword">this</span>; <span class="comment">// 同上</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> len = arr.length; <span class="comment">// 同上</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> param2 = <span class="built_in">arguments</span>[<span class="number">1</span>] || <span class="literal">undefined</span>; <span class="comment">// 同上</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> newArr = []; <span class="comment">// 用于返回的新的数组</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 同上</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 判断回调函数的返回值是否为真 =&gt; 为真返回对应item，为假不做处理</span></span></span><br><span class="line"><span class="actionscript">            func.apply(param2, [arr[i], i, arr]) ? newArr.push(arr[i]) : <span class="string">''</span>; </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> newArr;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> personArr = [</span></span><br><span class="line"><span class="actionscript">        &#123;name: <span class="string">'张三'</span>, sex: <span class="string">'m'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">        &#123;name: <span class="string">'李四'</span>, sex: <span class="string">'m'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">        &#123;name: <span class="string">'刘娜'</span>, sex: <span class="string">'f'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">        &#123;name: <span class="string">'李婷'</span>, sex: <span class="string">'f'</span>&#125;</span></span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> newArray = personArr.myFilter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, self</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> item.sex == <span class="string">'m'</span>;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(newArray); <span class="comment">// [&#123;name: '张三', sex: 'm'&#125;, &#123;name: '李四', sex: 'm'&#125;]</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="map-映射"><a href="#map-映射" class="headerlink" title="map: 映射"></a>map: 映射</h3><blockquote>
<p>Array.prototype.map(callbackfn(item, index, self), thisArg)</p>
</blockquote>
<ul>
<li>参数解释:<ul>
<li>callbackfn: 回调函数，item: 数组中的元素，index: 元素的索引，self: 数组本身。</li>
<li>thisArg: callbackfn中this的指向，不填的话this指向undefined。</li>
</ul>
</li>
<li>对数据进行集中化处理：会返回一个新数组</li>
<li>写个例子</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> personArr = [</span></span><br><span class="line"><span class="actionscript">            &#123; name: <span class="string">'张三'</span>, sex: <span class="string">'m'</span> &#125;,</span></span><br><span class="line"><span class="actionscript">            &#123; name: <span class="string">'李四'</span>, sex: <span class="string">'m'</span> &#125;,</span></span><br><span class="line"><span class="actionscript">            &#123; name: <span class="string">'刘娜'</span>, sex: <span class="string">'f'</span> &#125;,</span></span><br><span class="line"><span class="actionscript">            &#123; name: <span class="string">'李婷'</span>, sex: <span class="string">'f'</span> &#125;</span></span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> newArray = personArr.map(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, self</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//让item.name加上十，显示在li中</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>[index].innerHTML = item.name + <span class="number">10</span>;</span></span><br><span class="line">            </span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> item.name + <span class="number">10</span>;</span></span><br><span class="line"><span class="javascript">        &#125;, <span class="built_in">document</span>.getElementsByTagName(<span class="string">"li"</span>))</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// ['张三10', '李四10', ... ]</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(newArray); </span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ul>
<li>实现myMap</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">       <span class="built_in">Array</span>.prototype.myMap = <span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">           <span class="keyword">var</span> arr = <span class="keyword">this</span>; <span class="comment">// 同上</span></span></span><br><span class="line"><span class="actionscript">           <span class="keyword">var</span> len = arr.length; <span class="comment">// 同上</span></span></span><br><span class="line"><span class="javascript">           <span class="keyword">var</span> param2 = <span class="built_in">arguments</span>[<span class="number">1</span>] || <span class="literal">undefined</span>; <span class="comment">// 同上</span></span></span><br><span class="line"><span class="actionscript">           <span class="keyword">var</span> newArr = []; <span class="comment">// 用于返回的新的数组</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">           <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="actionscript">               <span class="comment">// 同上</span></span></span><br><span class="line"><span class="actionscript">               <span class="comment">// 拿到回调函数中的返回值，放到返回的新的数组中。</span></span></span><br><span class="line">               newArr.push( func.apply(param2, [arr[i], i, arr]) );</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">           <span class="keyword">return</span> newArr;</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">       <span class="keyword">let</span> personArr = [</span></span><br><span class="line"><span class="actionscript">           &#123; name: <span class="string">'张三'</span>, sex: <span class="string">'m'</span> &#125;,</span></span><br><span class="line"><span class="actionscript">           &#123; name: <span class="string">'李四'</span>, sex: <span class="string">'m'</span> &#125;,</span></span><br><span class="line"><span class="actionscript">           &#123; name: <span class="string">'刘娜'</span>, sex: <span class="string">'f'</span> &#125;,</span></span><br><span class="line"><span class="actionscript">           &#123; name: <span class="string">'李婷'</span>, sex: <span class="string">'f'</span> &#125;</span></span><br><span class="line">       ];</span><br><span class="line"></span><br><span class="line"><span class="javascript">       <span class="keyword">let</span> newArray = personArr.myMap(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, self</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">           <span class="comment">//让item.name加上十，显示在li中</span></span></span><br><span class="line"><span class="actionscript">           <span class="keyword">this</span>[index].innerHTML = item.name + <span class="number">10</span>;</span></span><br><span class="line">           </span><br><span class="line"><span class="actionscript">           <span class="keyword">return</span> item.name + <span class="number">10</span>;</span></span><br><span class="line"><span class="javascript">       &#125;, <span class="built_in">document</span>.getElementsByTagName(<span class="string">"li"</span>))</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">       <span class="comment">// ['张三10', '李四10', ... ]</span></span></span><br><span class="line"><span class="javascript">       <span class="built_in">console</span>.log(newArray); </span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="every-some-排查"><a href="#every-some-排查" class="headerlink" title="every,some: 排查"></a>every,some: 排查</h3><blockquote>
<p>Array.prototype.every(callbackfn(item, index, self), thisArg)</p>
<p>Array.prototype.some(callbackfn(item, index,self), thisArg)</p>
</blockquote>
<ul>
<li><p>参数解释:</p>
<ul>
<li>callbackfn: 回调函数，item: 数组中的元素，index: 元素的索引，self: 数组本身。</li>
<li>thisArg: callbackfn中this的指向，不填的话this指向undefined</li>
</ul>
</li>
<li><p>判断是否都满足规则，还是部分满足规则：</p>
<ul>
<li>every: 如果有一个返回false, 则返回false</li>
<li>some: 如果有一个返回true, 则返回true</li>
</ul>
</li>
<li><p>写个例子</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> personArr = [</span></span><br><span class="line"><span class="actionscript">            &#123; name: <span class="string">'张三'</span>, sex: <span class="string">'m'</span>, flag: <span class="string">'1'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">            &#123; name: <span class="string">'李四'</span>, sex: <span class="string">'m'</span>, flag: <span class="string">'1'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">            &#123; name: <span class="string">'刘娜'</span>, sex: <span class="string">'f'</span>, flag: <span class="string">'1'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">            &#123; name: <span class="string">'李婷'</span>, sex: <span class="string">'f'</span>,flag: <span class="string">'1'</span>&#125;</span></span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> newArr1 = personArr.every(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, self</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> item.name == <span class="string">'张三'</span>;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> newArr2 = personArr.some(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, self</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> item.name == <span class="string">'张三'</span></span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(newArr1, newArr2) <span class="comment">//false true </span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实现myEvery, mySome</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 如果有一个为假，则返回假</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Array</span>.prototype.myEvery = <span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> arr = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> len = <span class="keyword">this</span>.length;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> param2 = <span class="built_in">arguments</span>[<span class="number">1</span>] || <span class="literal">undefined</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> flag = <span class="literal">true</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="comment">// 判断回调函数的返回值, 如果有一个为假，则返回false; </span></span></span><br><span class="line">            if ( !func.apply(param2, [arr[i], i, arr]) ) &#123;</span><br><span class="line"><span class="actionscript">                flag = <span class="literal">false</span>;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> flag;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> flag;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 如果有一个为真，则返回真</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Array</span>.prototype.mySome = <span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> arr = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> len = <span class="keyword">this</span>.length;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> param2 = <span class="built_in">arguments</span>[<span class="number">1</span>] || <span class="literal">undefined</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> flag = <span class="literal">false</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="comment">// 判断回调函数的返回值, 如果有一个为真，则返回true; </span></span></span><br><span class="line">            if ( func.apply(param2, [arr[i], i, arr]) ) &#123;</span><br><span class="line"><span class="actionscript">                flag = <span class="literal">true</span>;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> flag;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> flag;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> personArr = [</span></span><br><span class="line"><span class="actionscript">        &#123; name: <span class="string">'张三'</span>, sex: <span class="string">'m'</span>, flag: <span class="string">'1'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">        &#123; name: <span class="string">'李四'</span>, sex: <span class="string">'m'</span>, flag: <span class="string">'1'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">        &#123; name: <span class="string">'刘娜'</span>, sex: <span class="string">'f'</span>, flag: <span class="string">'1'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">        &#123; name: <span class="string">'李婷'</span>, sex: <span class="string">'f'</span>,flag: <span class="string">'1'</span>&#125;</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> newArr1 = personArr.myEvery(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, self</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> item.name == <span class="string">'张三'</span>;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> newArr2 = personArr.mySome(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, self</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> item.name == <span class="string">'张三'</span></span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(newArr1, newArr2) <span class="comment">//false true </span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="reduce-reduceRight-累加器"><a href="#reduce-reduceRight-累加器" class="headerlink" title="reduce, reduceRight: 累加器"></a>reduce, reduceRight: 累加器</h3><blockquote>
<p>Array.prototype.reduce(callbackfn(pervValue, curValue, index, self), initialValue)</p>
<p>Array.prototype.some(callbackfn(pervValue, curValue, index, self), initialValue)</p>
</blockquote>
<ul>
<li><p>参数解释:</p>
<ul>
<li>callbackfn: 回调函数，pervValue: 回调函数上一次返回的值(初始值是initialValue里面的值)；curValue: 相当于每次回调函数中的item；index: item对应的索引；self: 数组本身</li>
<li>initialValue: 为pervValue赋初值</li>
</ul>
</li>
<li><p>判断是否都满足规则，还是部分满足规则：</p>
<ul>
<li>reduce: 从左向右累加</li>
<li>reduceRight: 从右向左累加</li>
</ul>
</li>
<li><p>写个例子</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> arr =  [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> initialValue = <span class="number">0</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> newStr1 = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">pervValue, curValue, index, self</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> pervValue + curValue;</span></span><br><span class="line">    &#125;, initialValue)</span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> newStr2 = arr.reduceRight(<span class="function"><span class="keyword">function</span> (<span class="params">pervValue, curValue, index, self</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> pervValue + curValue;</span></span><br><span class="line">    &#125;, initialValue)</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(newStr1, newStr2); <span class="comment">// 0abcde  0edcba</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实现myReduce和myReduceRight</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 扩展功能，可以添加this =&gt; 有 - 指向第三个参数； 没有 - undefined</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Array</span>.prototype.myReduce = <span class="function"><span class="keyword">function</span> (<span class="params">func, initialValue</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> arr = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> len = <span class="keyword">this</span>.length;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> param2 = <span class="built_in">arguments</span>[<span class="number">2</span>] || <span class="literal">undefined</span>; <span class="comment">// 运行时，指向的this</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="comment">// 第一次运行：pervValue = initialValue，初始化赋值</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 以后的每次运行：pervValue = initialValue; (initialValue 中存放的是回调函数每次的返回值)</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 把每次的回调函数的返回值重新赋值给initalValue</span></span></span><br><span class="line">            initialValue = func.apply(param2, [initialValue, arr[i], i, arr]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// 返回最后的返回值</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> initialValue;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 扩展功能，可以添加this =&gt; 有 - 指向第三个参数； 没有 - undefined</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">Array</span>.prototype.myReduceRight = <span class="function"><span class="keyword">function</span> (<span class="params">func, initialValue</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> arr = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> len = <span class="keyword">this</span>.length;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> param2 = <span class="built_in">arguments</span>[<span class="number">2</span>] || <span class="literal">undefined</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// 第一次运行：pervValue = initialValue，初始化赋值</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 以后的每次运行：pervValue = initialValue; (initialValue 中存放的是回调函数每次的返回值)</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 把每次的回调函数的返回值重新赋值给initalValue</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span></span><br><span class="line">            initialValue = func.apply(param2, [initialValue, arr[i], i, arr]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// 返回最后的返回值</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> initialValue;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> initialValue = <span class="number">0</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> newStr1 = arr.myReduce(<span class="function"><span class="keyword">function</span> (<span class="params">pervValue, curValue, index, self</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> pervValue + curValue;</span></span><br><span class="line">    &#125;, initialValue)</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> newStr2 = arr.myReduceRight(<span class="function"><span class="keyword">function</span> (<span class="params">pervValue, curValue, index, self</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> pervValue + curValue;</span></span><br><span class="line">    &#125;, initialValue)</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(newStr1, newStr2); <span class="comment">// 0abcde  0edcba</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="优雅地处理cookie信息"><a href="#优雅地处理cookie信息" class="headerlink" title="优雅地处理cookie信息"></a>优雅地处理cookie信息</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> cookieStr = <span class="string">"BAIDUID=D65DF4022E0C38AAF1B4346D69BE39D7:FG1; BIDUPSID=D65DF4022E0C38AAF1B4346D69BE39D7; PSTM=1567864658; BD_UPN=12314753; BDUSS=JPZlpMZnhnc0VwSzVZZmJCb0k0T1YtLVdJfnJoLVZTSjF4aVZVcEVTWFpaOFZkRVFBQUFBJCQAAAAAAAAAAAEAAABF9o-oxM-358jrz9JhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANnanV3Z2p1dej; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; BD_HOME=1; H_PS_PSSID=1461_21103_18559_29721_29568_29221; delPer=0; BD_CK_SAM=1; PSINO=1; COOKIE_SESSION=81759_0_8_7_4_5_0_1_8_3_0_0_0_0_0_0_1570804584_0_1570976916%7C9%236472_13_1568990992%7C4; BDSFRCVID=ZpusJeCCxG3jYbowCNdjqdmi-0CH6AQX2liC3J; H_BDCLCKID_SF=tbkD_C-MfIvhDRTvhCcjh-FSMgTBKI62aKDshtJa-hcqEpO9QTb8WtDe5PbwKPTD5Ij0sCJnWIQNVfP4h-rTDUTh-p52f60Dfn4O3J; H_PS_645EC=1749l%2FLqyeBp0aDhQvTDqO%2BJ1LCMP2QgXo9B9n4K1yd1eAJZ3oi6deolK%2Fw; BDSVRTM=127"</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">parseCookie</span><span class="params">(str)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 把字符串以分号分隔成数组</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> arrCookie = str.split(<span class="string">";"</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> cookieObj = &#123;&#125;;</span></span><br><span class="line"><span class="actionscript">        arrCookie.reduce(<span class="function"><span class="keyword">function</span> <span class="params">(prevValue, curValue, index, self)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 把字符串以=分割成数组</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> curArr = curValue.split(<span class="string">"="</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 放入到对象中</span></span></span><br><span class="line">            prevValue[curArr[0]] = curArr[1];</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> prevValue;</span></span><br><span class="line">        &#125;, cookieObj);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> cookieObj;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> cookieObj = parseCookie(cookieStr);</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(cookieObj);</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="动态的计算left"><a href="#动态的计算left" class="headerlink" title="动态的计算left"></a>动态的计算left</h3><ul>
<li>场景描述：当前元素的left = 前面元素的宽度 + 间隔；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [&#123; <span class="attr">width</span>: <span class="number">10</span> &#125;, &#123; <span class="attr">width</span>: <span class="number">20</span> &#125;, &#123; <span class="attr">width</span>: <span class="number">30</span> &#125;, &#123; <span class="attr">width</span>: <span class="number">40</span> &#125;, &#123; <span class="attr">width</span>: <span class="number">20</span> &#125;, &#123; <span class="attr">width</span>: <span class="number">30</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calLeft</span>(<span class="params">index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sumWidth = arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prevValue, curValue, i</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; index) &#123;</span><br><span class="line">            prevValue += (curValue.width + <span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prevValue;</span><br><span class="line"></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sumWidth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(calLeft(<span class="number">0</span>, arr)); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(calLeft(<span class="number">1</span>, arr)); <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(calLeft(<span class="number">2</span>, arr)); <span class="comment">// 50 </span></span><br><span class="line"><span class="built_in">console</span>.log(calLeft(<span class="number">3</span>, arr)); <span class="comment">// 90</span></span><br><span class="line"><span class="built_in">console</span>.log(calLeft(<span class="number">4</span>, arr)); <span class="comment">// 140</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Js基础</category>
      </categories>
      <tags>
        <tag>Js基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Ja基础-对函数（块）作用域的理解</title>
    <url>/2020/07/19/Js%E5%9F%BA%E7%A1%80/3.js%E5%9F%BA%E7%A1%80-%E5%AF%B9%E5%87%BD%E6%95%B0%E5%92%8C%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><ul>
<li>函数是JavaScript中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来。符合最小暴露原则。常用的软件设计原则。</li>
<li>和函数作用域一样的还有块级作用域ES3:with和try/catch；ES6中有: {}/let/const。</li>
<li>函数声明和函数表达式的区别：函数表达式被绑定在函数表达式自身的函数中而不是所在作用域。</li>
</ul>
<a id="more"></a>



<h4 id="什么是函数（块）作用域"><a href="#什么是函数（块）作用域" class="headerlink" title="什么是函数（块）作用域"></a>什么是函数（块）作用域</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(a, b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这上述的代码片段中，foo(…)函数包含了标识符a, bar。无论标识符出现在作用域的何处，这个标识符所代表的变量或函数都将附属于所处的作用域，但是这个标识符只能在函数内部对其进行访问（或者更下层的函数，bar函数中可以访问到foo函数内的变量a），外部是访问不到foo()函数内的标识符。</li>
<li>函数（块）作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用以及复用。</li>
</ul>
<h3 id="函数作用域的几个特点"><a href="#函数作用域的几个特点" class="headerlink" title="函数作用域的几个特点"></a>函数作用域的几个特点</h3><h4 id="隐藏内部实现"><a href="#隐藏内部实现" class="headerlink" title="隐藏内部实现"></a>隐藏内部实现</h4><ul>
<li><p>函数内部的变量是无法通过外部去访问的，可以把不想被外界访问的变量可以通过被函数”包裹”的方式，对变量进行”隐藏”，从而达到对变量的私有化。</p>
</li>
<li><p>谈一下”隐藏”变量和函数为什么是有用的技术？</p>
<ul>
<li>这种基于作用域的隐藏方法，大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必要内容，而其它内容都”隐藏”起来，比如某个模块或对象的API设计。</li>
</ul>
</li>
</ul>
<h4 id="规避冲突"><a href="#规避冲突" class="headerlink" title="规避冲突"></a>规避冲突</h4><ul>
<li>“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字却用途不一样，无意间造成的命名冲突。冲突会导致变量的值被意外覆盖，从而发生一些意想不到的事情</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        i = <span class="number">3</span>; <span class="comment">// 修改i的值</span></span><br><span class="line">        <span class="built_in">console</span>.log(a + i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        bar(i * <span class="number">2</span>); <span class="comment">// 无限循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数声明和函数表达式"><a href="#函数声明和函数表达式" class="headerlink" title="函数声明和函数表达式"></a>函数声明和函数表达式</h3><ul>
<li>怎么区分函数声明和函数表达式<ul>
<li>最简单的办法就是看function关键字出现的位置(整个声明中的位置)，如果function是声明中的第一个词，那么就是函数声明，否则就是函数表达式。</li>
</ul>
</li>
<li>关于函数声明和函数表达式的不同<ul>
<li>函数声明是绑定在声明的时候所处的作用域中，可以直接在其作用域内调用，<strong>函数表达式被绑定在函数表达式自身的函数中而不是所在作用域</strong>。</li>
<li>(function baz() {…})作为函数表达式意味着foo只能在..所代表的位置中被访问，外部作用域内不行，baz变量名被隐藏在自身中意味着不会非必要地污染外部作用域。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明: 整个作用域内都可以调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// 可以</span></span><br><span class="line"><span class="comment">// 函数表达式：只能在函数内部可以调用</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)()</span><br><span class="line">bar() <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式：bro只能在自己的函数作用域内被调用</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">bro</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'111'</span>)</span><br><span class="line">    bro();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 可以</span></span><br><span class="line">bro(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>



<h3 id="具名函数和匿名函数"><a href="#具名函数和匿名函数" class="headerlink" title="具名函数和匿名函数"></a>具名函数和匿名函数</h3><ul>
<li><p>具名函数：有名称的函数…</p>
</li>
<li><p>匿名函数：没有名称的函数…(匿名表达式都可以匿名的，而函数声明则不可以省略函数名)</p>
</li>
<li><p>匿名函数需要注意的几个缺点：</p>
<ul>
<li>匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。</li>
<li>如果没有函数名，当函数需要引用自身时会非常麻烦，可以使用过期的arguments.callee引用。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</li>
<li>匿名函数省略了对代码可读性/可理解性最重要的函数名。</li>
</ul>
</li>
<li><p>给函数表达式指定一个函数名可以有效解决以上的问题~</p>
</li>
</ul>
<h3 id="立即执行函数表达式（IIFE）"><a href="#立即执行函数表达式（IIFE）" class="headerlink" title="立即执行函数表达式（IIFE）"></a>立即执行函数表达式（IIFE）</h3><ul>
<li>立即执行函数的两种形式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种形式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种形式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种形式用哪种都可以，除了写的不同，其余都是一样的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>怎么把外部的参数传递到立即执行函数的内部</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">globle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">console</span>.log(globle.a) <span class="comment">// 3</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>利用IIFE倒置代码的运行顺序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; 3;</span><br><span class="line">(function IIFE(def) &#123;</span><br><span class="line">    def(window);</span><br><span class="line">    console.log(4);</span><br><span class="line">&#125;)(function def(global) &#123;</span><br><span class="line">    var a &#x3D; 2;</span><br><span class="line">    console.log(a); &#x2F;&#x2F; 2</span><br><span class="line">    console.log(global.a) &#x2F;&#x2F; 3</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印顺序：234</span><br></pre></td></tr></table></figure>

<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><ul>
<li>用with从对象创建出的作用域仅在with声明中而非外部作用域中有效</li>
</ul>
<h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try/catch"></a>try/catch</h4><ul>
<li>在ES3规范中规定try/catch的catch部分会创建一个块作用域，其中声明的变量仅在catch内部有效</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="literal">undefined</span>(); <span class="comment">// 执行一些错误的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">//打印错误的信息： ReferenceError: undefined is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(err); <span class="comment">//未声明变量： Uncaught ReferenceError: err is not defined</span></span><br></pre></td></tr></table></figure>

<h4 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h4><ul>
<li>ES6中新增的关键字，两种声明变量的方式</li>
<li>与var不同的时，let/const关键字可以将变量绑定在所在的任何作用域中，一般是{…}内部，也就是说，let/const为其声明的变量隐式地劫持了所在的块作用域。</li>
<li>let与const的不同是，const定义的是常量，一经赋值，就无法修改，const需要注意的两点，一是const必须要声明时赋值，二是const声明对象时，不可修改的部分是对象的引用，而不是对象内部定义的其他相关变量或者函数。也就是在用const定义对象之后，仍然后可以修改对象中的属性和方法。</li>
<li>为变量显式声明块作用域，在引擎垃圾回收时，对于已经用过的，没有产生闭包的变量，会进行垃圾回收，从而释放空间。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// js引擎对下面这段代码执行完毕之后，进行垃圾回收</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> someRealData = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    process(someRealData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'btn click'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="let用于for循环解决的问题"><a href="#let用于for循环解决的问题" class="headerlink" title="let用于for循环解决的问题"></a>let用于for循环解决的问题</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(j); <span class="comment">// 0,1,2,...,9</span></span><br><span class="line">    &#125;, j)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(j); <span class="comment">// ReferenceError: j is not defined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>let在每次循环时，都会隐式的生成一个新的块作用域，包含let每次所声明的变量(let = 0; let = 1; let = 2; …)以及其余的代码。</li>
<li>谈一下用var循环为什么会带来这种问题，首先var i = 0; 会把i放到全局作用域中，然后执行代码，在碰到定时器函数，把函数扔到宏队列等待js主线程的代码执行完毕再去执行宏队列中的代码，当for循环结束时，此时的i=10；然后执行存放在宏队列中的定时器，定时器函数所在的作用域中没有i变量，通过作用域链查找，查找的全局作用域中的i=10；于是每次打印都会打印10。而let不同的是，定时器中的函数在寻找i变量时，会找到上层let所隐式创建的块作用域，在这个作用域的i时let i；每次声明时所赋值的i变量。</li>
<li>也可以用立即执行函数传参的方式解决上述的问题，其思想和let差不多，都是创建作用域，把值放入当前的作用域。</li>
</ul>
]]></content>
      <categories>
        <category>Js基础</category>
      </categories>
      <tags>
        <tag>Js基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Js基础-对词法作用域的理解（eval和with剖析）</title>
    <url>/2020/07/18/Js%E5%9F%BA%E7%A1%80/2.Js%E5%9F%BA%E7%A1%80-%E5%AF%B9%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>词法作用域意味着是有书写代码时函数声明的位置决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。</li>
<li>词法作用域的在Js引擎的编译阶段就已经是固定的（大部分情况下）。</li>
<li>欺骗词法eval()和with:这两个机制的副作用是引擎无法在编译阶段对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的，导致的结果是将代码运行变慢。<strong>不能使用它们</strong></li>
</ul>
<a id="more"></a>

<h3 id="词法作用域详解"><a href="#词法作用域详解" class="headerlink" title="词法作用域详解"></a>词法作用域详解</h3><h4 id="词法阶段"><a href="#词法阶段" class="headerlink" title="词法阶段"></a>词法阶段</h4><ul>
<li>简单来说词法作用域就是定义在词法阶段的作用域。也就是词法作用域是由你写在代码时将变量和块作用域写在哪里决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = a * <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c)</span><br><span class="line">  &#125;</span><br><span class="line">  bar(b * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述代码共有三个作用域<ul>
<li>1是包含整个全局作用域，只有一个标识符：foo。</li>
<li>2是包含foo函数所创建的作用域，有三个标识符：a,bar,和b。</li>
<li>3是包含bar所创建的作用域，其中只有一个标识符：c。</li>
</ul>
</li>
</ul>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ul>
<li>每个作用域之间的结构和互相之间的位置给引擎提供了足够的信息，引擎用这些信息来查找标识符的位置。</li>
<li>作用域查找会在找到的第一个匹配的标识符停止。在多层的嵌套作用域中可以定义同名的标识符（不建议这样做），这叫做”遮蔽效应”（内部的标识符”遮蔽”了外部的标识符）。</li>
<li>作用域查找始终从运行所处的最内部作用域开始，逐级向外或者向上进行，知道遇见第一个匹配的标识符为止。</li>
</ul>
<h4 id="欺骗词法"><a href="#欺骗词法" class="headerlink" title="欺骗词法"></a>欺骗词法</h4><ul>
<li>已经知道的是词法作用域已经在编译阶段已经固定好的，怎么才能在运行时来”修改”词法作用域？</li>
<li>在JavaScript中有两个机制(eval(),with)可以实现在代码运行时,来改变词法作用域，当然，不建议使用，因为欺骗词法会导致性能下降（引擎在遇到这两个’魔鬼’时，会害怕的不”敢”去优化作用域）。</li>
<li>关于eval()和with：with已经在严格模式在被禁用，eval()也不建议去使用。</li>
</ul>
<h4 id="探索eval"><a href="#探索eval" class="headerlink" title="探索eval()"></a>探索eval()</h4><ul>
<li>JavaScript中的eval()可以接受一个字符串为参数，并将其中内容视为好像在书写时就存在于程序中这个位置的代码。换句话说，可以在你写的代码中用程序生成代码并运行，就好像代码是写在那个位置一样。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">eval</span>(str); <span class="comment">// 欺骗 -&gt; 把eval里面字符串拉扯到当前的作用域中</span></span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(<span class="string">'var b = 3;'</span>, <span class="number">1</span>); <span class="comment">// 1, 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>eval()会把字符串var b = 3;在运行期间拉扯到foo函数的作用域内，而且全局的var b = 2;也会被遮蔽效应给遮蔽掉。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="built_in">eval</span>(str);</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="string">'var a = 2;'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>在严格模式下，eval()会自成一域(作用域),意味着其中的声明无法修改所在的作用域，因为外层的作用域无法查找内层的作用域。</li>
</ul>
<h4 id="探索with"><a href="#探索with" class="headerlink" title="探索with"></a>探索with</h4><ul>
<li>从with是如何同被它影响的词法作用域进行交互的。</li>
<li>with通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 简单乏味的重复'obj'</span></span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line">obj.b = <span class="number">3</span>;</span><br><span class="line">obj.c = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 简单的快捷方式</span></span><br><span class="line"><span class="keyword">with</span>(obj) &#123;</span><br><span class="line">  a = <span class="number">3</span>;</span><br><span class="line">  b = <span class="number">4</span>;</span><br><span class="line">  c = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方面的访问对象属性仅仅一个方面，</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span>(obj) &#123;</span><br><span class="line">    a = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">  a: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">  b: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(o1);</span><br><span class="line"><span class="built_in">console</span>.log(o1.a); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">foo(o2);</span><br><span class="line"><span class="built_in">console</span>.log(o2.a); <span class="comment">// undefined -&gt; 理解为什么是undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2 -&gt; a被泄露到全局作用域上了 -&gt; 理解为什么是2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在with内部，写的代码看起来像是对变量a进行简单的词法引用，实际上就是一个LHS引用，并将2赋值给它。</li>
<li>当我们将o1传递进去，a = 2赋值操作找到了o1.a并将2赋值给它，在后面console.log(o1.a)打印了2；</li>
<li>当我们把o2传递进行，a=2赋值操作并不能找到o2中的a属性，因为o2中没有a属性，当引擎处理a=2时，利用LHS引用，去查找a是否存在，在其作用域内没有找到a，于是在全局创建 var a（非严格模式）;并将2赋值给a,于是产生了两种情况，一是在o2.a并没有此属性，会打印undefined，此时a被创建在全局作用域中，并把2赋值给全局作用域中的a，打印a=2。</li>
<li>eval()函数如果接受了含有一个或多个声明的代码，就会修改所在的词法作用域，而with声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。</li>
</ul>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul>
<li>为什么eval()和with会性能下降？<ul>
<li>JavaScript引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符，如果引擎在代码中发现了eval()或with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确eval()会接受到什么代码，这些代码会如何对作用域进行修改，也无法知道传递个with用来创建新词法作用域的对象的内容到底是什么。</li>
</ul>
</li>
<li>最悲观的情况如果出现eval()或with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。</li>
</ul>
]]></content>
      <categories>
        <category>Js基础</category>
      </categories>
      <tags>
        <tag>Js基础</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-策略模式</title>
    <url>/2020/07/17/designPattern/7.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><ul>
<li>策略模式是指对一系列的算法定义，并将一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</li>
<li>策略模式的优点有：策略模式提供了管理相关算法族的办法、策略模式提供了可以替换继承关系的办法、使用策略模式可以避免使用多重条件转移语句。</li>
<li>业务复杂度达到一定程度了我们才选用设计模式去解决复杂的问题，扩展性，复用性，冗余度，小的情况没有必要使用。</li>
</ul>
<a id="more"></a>


<h3 id="设计模式-策略模式-特点说明"><a href="#设计模式-策略模式-特点说明" class="headerlink" title="设计模式-策略模式-特点说明"></a>设计模式-策略模式-特点说明</h3><ul>
<li>策略模式支持你在运行时选择算法，把他们一个一个封装起来，并使他们可以相互替换。</li>
<li>决定一个类对象实例来管理规则的校验。</li>
<li>该对象要能，相应的主动添加对规则的相应的处理办法。</li>
<li>校验数据的时候可以相应的返回相关信息</li>
</ul>
<h3 id="【例子】：优雅的处理校验"><a href="#【例子】：优雅的处理校验" class="headerlink" title="【例子】：优雅的处理校验"></a>【例子】：优雅的处理校验</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数 -&gt; 创建对象实例</span></span><br><span class="line"><span class="comment">// 迎合策略模式的一个对象</span></span><br><span class="line"><span class="comment">// 符合开闭原则</span></span><br><span class="line"><span class="comment">// add: 参数1:校验内容dom, 参数2: 错误信息显示dom，参数3: 校验规则</span></span><br><span class="line"><span class="comment">// add 添加校验规则（dom(校验谁), showDom(错误的信息展示到哪里),[&#123;strategy（策略）: 'isNonEmpty（策略实现）', errorMsg（错误返回的信息）: '用户名不为空'&#125;, &#123;strategy: 'maxLength:4', errorMsg: '用户名长度不能超过4'&#125;]）</span></span><br><span class="line"><span class="comment">// start 开始校验并返回真正的校验结果</span></span><br><span class="line"><span class="comment">// extend 可以扩展 算法 &#123;isMail(算法名称): function () &#123;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Validator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = []; <span class="comment">// 缓存作用 -&gt; 把所有执行的校验放入其中，等待start()执行</span></span><br><span class="line">    <span class="keyword">this</span>.warnDom = []; <span class="comment">// 存放提示信息标签的id -&gt; 清除上次的提示信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化校验规则</span></span><br><span class="line">Validator.prototype.strategies = &#123;</span><br><span class="line">    <span class="comment">// 判断是否为空</span></span><br><span class="line">    isNonEmpty: <span class="function"><span class="keyword">function</span> (<span class="params">value, errorMsg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="string">''</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 判断长度最大不能超过几</span></span><br><span class="line">    maxLength: <span class="function"><span class="keyword">function</span> (<span class="params">value, length, errorMsg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="string">''</span> &amp;&amp; value.length &gt; length) &#123;</span><br><span class="line">            <span class="keyword">return</span> errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 判断长度最小不能小于几</span></span><br><span class="line">    minLength: <span class="function"><span class="keyword">function</span> (<span class="params">value, length, errorMsg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="string">''</span> &amp;&amp; value.length &lt; length) &#123;</span><br><span class="line">            <span class="keyword">return</span> errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用校验规则 -&gt; 只调用，不触发</span></span><br><span class="line">Validator.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params">dom, showdom, strategyArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 把提示标签放到warnDom里面</span></span><br><span class="line">    <span class="keyword">this</span>.warnDom.push(showdom)</span><br><span class="line">    strategyArr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index</span>) </span>&#123;</span><br><span class="line">        self.cache.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 把方法缓存到cache</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 'maxLength:4'.split[':'] ==&gt; ['maxLength', '4']</span></span><br><span class="line">            <span class="comment">// arr = ['isNonEmpty'] 第一圈</span></span><br><span class="line">            <span class="comment">// arr = ['maxLength', '4']  第二圈</span></span><br><span class="line">            <span class="keyword">var</span> arr = ele.stratrgy.split(<span class="string">':'</span>); <span class="comment">// 用冒号拆分</span></span><br><span class="line">            <span class="comment">// shift =&gt; 删除数组中第一个元素并返回</span></span><br><span class="line">            <span class="comment">// arr =&gt; [], ['4']</span></span><br><span class="line">            <span class="comment">// type =&gt; isNonEmpty maxLength</span></span><br><span class="line">            <span class="keyword">var</span> type = arr.shift();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// unshift: 把元素加到数组的第一位</span></span><br><span class="line">            <span class="comment">// [dom.value] [dom.value, '4']</span></span><br><span class="line">            arr.unshift(dom.value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// [dom.value, errorMsg] [dom.value, '4', errorMsg]</span></span><br><span class="line">            arr.push(ele.errorMsg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回true或者false</span></span><br><span class="line">            <span class="keyword">var</span> msg = self.strategies[type].apply(self, arr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 这里只是提示，没有清空</span></span><br><span class="line">                showdom.innerText = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发校验规则 -&gt; 返回校验处理信息 -&gt; true/false</span></span><br><span class="line">Validator.prototype.start = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">true</span>; <span class="comment">// 标记最后是否能符合规则</span></span><br><span class="line">    <span class="keyword">this</span>.warnDom.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 每次提交之前先清空提示信息</span></span><br><span class="line">        ele.innerText = <span class="string">''</span>;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.cache.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ele() != <span class="literal">true</span>) &#123; <span class="comment">// 判断执行之后的返回值是否等于true</span></span><br><span class="line">            flag = <span class="literal">false</span>; <span class="comment">// 如果有一个不是true最后flag就会等于false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展校验规则 -&gt; 把扩展的校验规则放入strategies中等待被调用</span></span><br><span class="line"></span><br><span class="line">Validator.prototype.extend = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// config是扩展放的总和 -&gt; 对象</span></span><br><span class="line">    <span class="comment">// 遍历每一个对象 -&gt; 把规则放到strategies中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> config) &#123;</span><br><span class="line">        Validator.prototype.strategies[prop] = config[prop];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-观察者模式（复习知识点）</title>
    <url>/2020/07/17/designPattern/6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><ul>
<li>解释说明：作为观察者的你，订阅了一些消息，被观察者在有消息的时候就会通知你，并且把消息给到你。这个模式存在的意义就是解耦，被观察者无需关心你如何处理消息。</li>
<li>观察者的使用场合：当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。</li>
</ul>
<a id="more"></a>

<h3 id="设计模式-观察者模式"><a href="#设计模式-观察者模式" class="headerlink" title="设计模式-观察者模式"></a>设计模式-观察者模式</h3><ul>
<li>定义：观察者模式，定义对象间的一种一多的依赖关系，当一个对象的状态发生改变时，所有依赖它的对象都将得到通知。 </li>
<li>事件机制本身就是一种观察者模式，下面实现的例子，也是实现一个事件机制。</li>
</ul>
<h3 id="【例子】实现一个Event模块-发布消息，订阅消息，退订消息"><a href="#【例子】实现一个Event模块-发布消息，订阅消息，退订消息" class="headerlink" title="【例子】实现一个Event模块[发布消息，订阅消息，退订消息]"></a>【例子】实现一个Event模块[发布消息，订阅消息，退订消息]</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// Event</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 1. Event on:绑定自定义事件; emmit：触发自定义事件; remove：清除自定义事件;</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 2. 有助于了解观察者模式</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 3. node 模块中经常会使用到</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">Event</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 存储 不同事件类型对应的不同处理函数</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.cache = &#123;&#125;;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        Event.prototype.on = <span class="function"><span class="keyword">function</span> <span class="params">(type, handle)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 把绑定的事件存储到对应的类型中</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (!<span class="keyword">this</span>.cache[type]) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.cache[type] = [handle]</span></span><br><span class="line"><span class="actionscript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.cache[type].push(handle);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        Event.prototype.emmit = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> type = <span class="built_in">arguments</span>[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> arg = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> len = <span class="keyword">this</span>.cache[type].length;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="comment">// 触发类型对应的自定义事件</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.cache[type][i].apply(<span class="keyword">this</span>, arg);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        Event.prototype.empty = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          	<span class="comment">// 清空缓存</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.cache[type] = [];</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        Event.prototype.remove = <span class="function"><span class="keyword">function</span> <span class="params">(type, handle)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          	<span class="comment">// 过滤对应类型的函数 -&gt; 删除自定义绑定事件</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.cache[type] = <span class="keyword">this</span>.cache[type].filter(<span class="function"><span class="keyword">function</span> <span class="params">(ele)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> !(ele == handle);</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> oE = <span class="keyword">new</span> Event();</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">      	<span class="comment">// 自定义事件1</span></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">deal1</span><span class="params">(time)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'overtime1:'</span> + time);</span></span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line"><span class="actionscript">        oE.on(<span class="string">'over'</span>, deal1);</span></span><br><span class="line">		</span><br><span class="line"><span class="actionscript">      	<span class="comment">// 自定义事件2</span></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">deal2</span><span class="params">(time)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'overtime2:'</span> + time);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        oE.on(<span class="string">'over'</span>, deal2)</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        oE.emmit(<span class="string">'over'</span>, <span class="string">'2020-07-17'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        oE.remove(<span class="string">'over'</span>, deal2);</span></span><br><span class="line"><span class="actionscript">        oE.emmit(<span class="string">'over'</span>, <span class="string">'second-2020-07-17'</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Js基础-对作用域的理解（从JS引擎方面）</title>
    <url>/2020/07/16/Js%E5%9F%BA%E7%A1%80/1.Js%E5%9F%BA%E7%A1%80-%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li>作用域：作用域就是一套规则，这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找；如果查找的目的是对其进行赋值，那么就会使用LHS查询；如果目的是获取目的变量的值，那么就会使用RHS查找；不成功的RHS引用会导致抛出ReferenceError异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），严格模式下，不成功的LHS引用也会导致抛出ReferenceError异常。</li>
</ul>
<a id="more"></a>


<h3 id="作用域详解"><a href="#作用域详解" class="headerlink" title="作用域详解"></a>作用域详解</h3><h4 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h4><blockquote>
<p>谈作用域为什么会说到编译原理，虽然js是解释性语言，但是根本上它本是一门编译语言，因为在js执行的前几微秒内是js编译阶段，这个阶段非常重要，包括了对源码编译和js引擎用尽了各种办法（比如JIT,可以延迟编译甚至实施重编译）来保证性能最佳，程序中的一段源码在执行之前会经历三个步骤，统称为”编译”，在编译阶段，编译器会询问作用域关于变量的种种，来确定变量是否创建、内存分配以及对其赋值。</p>
</blockquote>
<ul>
<li>分词/词法分析（Tokenizing/Lexing）<ul>
<li>这个过程会将由字符串分解成有意义的代码块，这些代码块被称为词法单元(token)。例如，考虑程序var a = 2;。这段程序通常会被分解成为下面这些词法单元: var、a、=、2、;。空格是否会被当作词法单元，取决于空格在这门语言是否具有意义。</li>
</ul>
</li>
<li>解析/语法分析（Parsing）<ul>
<li>这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree, AST)。</li>
</ul>
</li>
<li>代码生成<ul>
<li>将AST转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等息息县关</li>
<li>抛开具体细节，简单来说就是某种方法可以将var a = 2;的AST抽象语法树转化为一组机器指令，用来创建一个叫a的变量（包括内存分配），并将一个值存储在中。</li>
</ul>
</li>
</ul>
<h4 id="理解作用域"><a href="#理解作用域" class="headerlink" title="理解作用域"></a>理解作用域</h4><ul>
<li>如何才能更好的去理解作用域是什么，把它模拟成几个重要人物的对话。</li>
</ul>
<ul>
<li>从三个视角对整个js编译和执行的过程进行理解和拆分<ul>
<li>引擎：从头到尾负责整个JavaScript程序的编译及执行的过程</li>
<li>编译器：引擎的好朋友之一，负责语法分析和代码生成的工作</li>
<li>作用域：引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限</li>
</ul>
</li>
</ul>
<h5 id="作用域和编译器的对话"><a href="#作用域和编译器的对话" class="headerlink" title="作用域和编译器的对话"></a>作用域和编译器的对话</h5><blockquote>
<p>var a = 2; 编译器和作用域是如何对这段代码进行操作的？</p>
</blockquote>
<ul>
<li>遇到var a,编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名a。</li>
<li>接下来编译器会为引擎生成运行时所需要的代码，这些代码被用来处理a = 2;这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫做a的变量。如果是，引擎就会继续使用这个变量；如果否，引擎会继续查找该变量。</li>
<li>总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域声明一个变量（如果之前没有声明），然后再运行时引擎会在作用域查找该变量，如果能找到就会对它赋值。</li>
<li>额外的信息：从上面的两段话，可以看出，当在编译阶段（还未执行代码），js引擎就已经把变量给放到了作用域中，在代码执行阶段，才对其赋值，这里就已经暗示了变量提升。</li>
</ul>
<h5 id="编译器中的LHS和RHS"><a href="#编译器中的LHS和RHS" class="headerlink" title="编译器中的LHS和RHS"></a>编译器中的LHS和RHS</h5><ul>
<li><p>当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧进行RHS查询。讲得更准确一点，RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是视图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// RHS引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>; <span class="comment">// LHS引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">c</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(c); <span class="comment">// RHS引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">2</span>); <span class="comment">// LHS引用 c = 2;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么会用到LHS和RHS一是引擎在查找变量时会用到，二是LHS和RHS对于未找到情况的两种异常的处理。</p>
</li>
</ul>
<h5 id="引擎和作用域的对话"><a href="#引擎和作用域的对话" class="headerlink" title="引擎和作用域的对话"></a>引擎和作用域的对话</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"> 	<span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>引擎和作用域之间是如何处理上面这段代码</p>
<ul>
<li>引擎：首先询问作用域，对foo进行RHS引用</li>
<li>作用域：判断编译器是否声明了foo，不存在，报错，存在，变量还是函数</li>
<li>引擎：执行foo()</li>
<li>引擎：在执行foo时，询问作用域，对a进行LHS引用</li>
<li>作用域：判断编译器是否声明了a的形参，不存在：报错，存在：告诉引擎</li>
<li>引擎：对a赋值2</li>
<li>引擎：询问作用域，为console进行RHS的引用</li>
<li>作用域：console为内置对象，存在：告诉作用域</li>
<li>引擎：寻找内置对象console中是否存在log()方法</li>
<li>引擎：询问作用域，对a进行RHS引用</li>
<li>作用域：在作用域中寻找a，不存在：报错，存在：告诉引擎</li>
<li>引擎：对a进行赋值，传递到log()，执行console.log()。</li>
</ul>
<h4 id="作用域嵌套和作用域中变量（标识符）查找规则"><a href="#作用域嵌套和作用域中变量（标识符）查找规则" class="headerlink" title="作用域嵌套和作用域中变量（标识符）查找规则"></a>作用域嵌套和作用域中变量（标识符）查找规则</h4><ul>
<li>总结：当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套（作用域链）。因此在当前作用域无法寻找某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域为止。</li>
</ul>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ul>
<li>为什么区分LHS和RHS是很重要的事情<ul>
<li>因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是完全不一样的。</li>
</ul>
</li>
<li>在作用域中用 RHS进行变量查找时，并且查找的规则是从当前作用域开始找，如果没找到再到父级作用域中找，一层层往外找，如果在全局作用域如果还没找到的话，就会报错了：ReferenceError: 某变量 is not defined</li>
<li>在作用域用LHS查找变量时，如果在顶层也没有查找到改变量，全局作用域中就会创建一个具有该名称的变量，并将其返回给引擎，前提是程序在非“严格模式”下。在严格模式中，LHS也会抛出一个：ReferenceError。</li>
</ul>
]]></content>
      <categories>
        <category>Js基础</category>
      </categories>
      <tags>
        <tag>Js基础</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-装饰者模式（知识点复习）</title>
    <url>/2020/07/16/designPattern/5.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><ul>
<li>装饰者（decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责。与继承相比，装饰者是一种更轻便灵活的做法。可以当脚本运行时，在子类中增加行为会影响原有类所有的实例，给不同对象各自添加新行为和属性。</li>
</ul>
<a id="more"></a>

<h3 id="设计模式-装饰者模式"><a href="#设计模式-装饰者模式" class="headerlink" title="设计模式-装饰者模式"></a>设计模式-装饰者模式</h3><ul>
<li>定义：在不改变元对象的基础上，通过对其他包装扩展（添加属性方法）</li>
<li>实现：构造函数需要一个装饰资源池，提供相应的装饰方法，提供添加装饰方法的方法。</li>
</ul>
<h3 id="【例子】工厂模式和装饰模式放一起的例子"><a href="#【例子】工厂模式和装饰模式放一起的例子" class="headerlink" title="【例子】工厂模式和装饰模式放一起的例子"></a>【例子】工厂模式和装饰模式放一起的例子</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 装饰者模式</span></span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">PlaneFactory</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.decorate_list = []; <span class="comment">// 资源池：同一种类型使用装饰方法，此种类型的所有实例都会作用上</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 集合了所有装饰方法</span></span></span><br><span class="line">        PlaneFactory.prototype.decorators = &#123;</span><br><span class="line"><span class="actionscript">            eatOneLife: <span class="function"><span class="keyword">function</span> <span class="params">(obj)</span> </span>&#123;</span></span><br><span class="line">                obj.blood += 100;</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            eatTwoLife: <span class="function"><span class="keyword">function</span> <span class="params">(obj)</span> </span>&#123;</span></span><br><span class="line">                obj.blood += 200;</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            eatShrinkLife: <span class="function"><span class="keyword">function</span> <span class="params">(obj)</span> </span>&#123;</span></span><br><span class="line">                obj.blood -= 50;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// 搜集对某对象的装饰描述</span></span></span><br><span class="line"><span class="actionscript">        PlaneFactory.prototype.decorate = <span class="function"><span class="keyword">function</span> <span class="params">(decorate)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.decorate_list_self = []; <span class="comment">// 资源池：单个实例使用装饰方法，指挥更新对应的实例，不会影响到同类的实例</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.decorate_list.push(decorate);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// 让装饰方法作用在该对象的身上</span></span></span><br><span class="line"><span class="actionscript">        PlaneFactory.prototype.update = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.decorate_list.length; i++) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.decorators[<span class="keyword">this</span>.decorate_list[i]] &amp;&amp; <span class="keyword">this</span>.decorators[<span class="keyword">this</span>.decorate_list[i]](<span class="keyword">this</span>)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// 清空资源装饰池</span></span></span><br><span class="line"><span class="actionscript">        PlaneFactory.prototype.emtry = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.decorate_list = [];</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// 清楚单个资源装饰池</span></span></span><br><span class="line"><span class="actionscript">        PlaneFactory.prototype.remove = <span class="function"><span class="keyword">function</span> <span class="params">(type)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.decorate_list = <span class="keyword">this</span>.decorate_list.filter(<span class="function"><span class="keyword">function</span> <span class="params">(ele, index)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> !(ele == type);</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// 子类继承父类的公用方法</span></span></span><br><span class="line"><span class="actionscript">        PlaneFactory.prototype.touch = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.blood -= <span class="number">50</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (<span class="keyword">this</span>.blood == <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.die();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        PlaneFactory.prototype.die = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            alert(<span class="string">'boooom!~'</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// 创建对象接口</span></span></span><br><span class="line"><span class="actionscript">        PlaneFactory.create = <span class="function"><span class="keyword">function</span> <span class="params">(type)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 判断是否存在此原型</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (PlaneFactory.prototype[type] == <span class="literal">undefined</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">throw</span> <span class="string">'no this constructor'</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="comment">// 继承：把子类的原型指向PlaneFactory的原型上</span></span></span><br><span class="line">            if (PlaneFactory.prototype[type].prototype.__proto__ !== PlaneFactory.prototype) &#123;</span><br><span class="line"><span class="actionscript">                PlaneFactory.prototype[type].prototype = <span class="keyword">new</span> PlaneFactory();</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="comment">// 把参数传进来</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> arg = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> newPlane = <span class="keyword">new</span> PlaneFactory.prototype[type](...arg);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> newPlane;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// 真正定义子类工厂</span></span></span><br><span class="line"><span class="actionscript">        PlaneFactory.prototype.SmallPlane = <span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.x = x;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.y = y;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.width = <span class="number">100</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.height = <span class="number">100</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.blood = <span class="number">100</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.name = <span class="string">'SmallPlane'</span>;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        PlaneFactory.prototype.BigPlane = <span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.x = x;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.y = y;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.width = <span class="number">200</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.height = <span class="number">200</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.blood = <span class="number">100</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.name = <span class="string">'BigPlane'</span>;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        PlaneFactory.prototype.AttackPlane = <span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.x = x;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.y = y;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.width = <span class="number">150</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.height = <span class="number">150</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.blood = <span class="number">100</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.name = <span class="string">'AttackPlane'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.attack = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">'dadada'</span>)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> oAp = PlaneFactory.create(<span class="string">'AttackPlane'</span>, <span class="number">10</span>, <span class="number">20</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> oSp = PlaneFactory.create(<span class="string">'SmallPlane'</span>, <span class="number">20</span>, <span class="number">30</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> oBp = PlaneFactory.create(<span class="string">'BigPlane'</span>, <span class="number">30</span>, <span class="number">40</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// 装饰者模式</span></span></span><br><span class="line"><span class="actionscript">        oAp.decorate(<span class="string">'eatOneLife'</span>);</span></span><br><span class="line"><span class="actionscript">        oAp.decorate(<span class="string">'eatTwoLife'</span>);</span></span><br><span class="line"><span class="actionscript">        oAp.remove(<span class="string">'eatOneLife'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// oAp.update();</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂模式（知识点复习）</title>
    <url>/2020/07/13/designPattern/4.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><ul>
<li>主要讨论的是工厂方法模式</li>
<li>不再有一个唯一的工厂类就创建产品，而是将不同的产品交给对应的工厂子类去实现。每个产品由负责生产的自工厂来创造。如果添加新的产品，需要做的是添加新的子工厂和产品，而不是修改其他的工厂代码。</li>
</ul>
<a id="more"></a>

<h3 id="设计模式-工厂模式"><a href="#设计模式-工厂模式" class="headerlink" title="设计模式-工厂模式"></a>设计模式-工厂模式</h3><ul>
<li>定义：工厂模式定义创建对象接口，但是让子类去真正的实例化。也就是工厂方法将类的实例化延迟到子类。</li>
</ul>
<h3 id="设计模式-工厂方法模式"><a href="#设计模式-工厂方法模式" class="headerlink" title="设计模式 - 工厂方法模式"></a>设计模式 - 工厂方法模式</h3><ul>
<li>工厂方法模式：不再有一个唯一的工厂类就创建产品，而是将不同的产品交给对应的工厂子类去实现。每个产品由负责生产的自工厂来创造。如果添加新的产品，需要做的是添加新的子工厂和产品，而不是修改其他的工厂代码。</li>
</ul>
<h4 id="工厂方法模式组成"><a href="#工厂方法模式组成" class="headerlink" title="工厂方法模式组成"></a>工厂方法模式组成</h4><ul>
<li>1.抽象工厂类：负责定义创建产品的公共接口。</li>
<li>2.产品子工厂：继承抽象工厂类，实现抽象工厂类提供的接口。</li>
<li>3.每一种产品有各自的产品类</li>
</ul>
<h3 id="【例子】：对比原始模式、简单工厂模式、工厂方法模式"><a href="#【例子】：对比原始模式、简单工厂模式、工厂方法模式" class="headerlink" title="【例子】：对比原始模式、简单工厂模式、工厂方法模式"></a>【例子】：对比原始模式、简单工厂模式、工厂方法模式</h3><ul>
<li>先说结论<ul>
<li>在不同业务场景下应用不同的设计思想，对于无需迭代的项目，尽量不要引入模式的概念，增大了开发难度，理解难度和开发周期。对需要迭代的项目，选一种合适的模式，对业务进行搭建，可以事半功倍。</li>
<li>工厂模式对比其他模式（对象，单一构造函数）<ul>
<li>工厂类集合了所有对象的创建，便于对象创建的统一管理。</li>
<li>对象的使用者仅仅是使用产品，实现了单一职责。</li>
<li>便于扩展，如果新增了一种业务，只需要增加相关的业务对象类和工厂类的生产业务对象的方法，不需要修改其他的地方。</li>
<li>但是违反了开闭原则。</li>
</ul>
</li>
<li>分析简单工厂模式和工厂方法模式<ul>
<li>代码比简单工厂模式复杂了，引入抽象层，还有子工厂，这会增加代码的复杂度和理解难度。但是相当于简单工厂模式，代码的维护性和扩展性提高了，新增产品时，只需要增加对应的产品类和产品工厂类，不需要修改到抽象工厂类和其他子工厂。更加符合面向对象的开放封闭原则。</li>
</ul>
</li>
<li>当然具体场景具体分析，复杂性和扩展性相比如何舍去，在使用的时候要结合实际场景去分析。</li>
</ul>
</li>
</ul>
<h4 id="原始模式的实现"><a href="#原始模式的实现" class="headerlink" title="原始模式的实现"></a>原始模式的实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 原始模式创建对象 -&gt; 只能创建一个对象</span></span><br><span class="line"><span class="keyword">var</span> SmallPlane = &#123;</span><br><span class="line">    width: <span class="number">100</span>,</span><br><span class="line">    height: <span class="number">100</span>,</span><br><span class="line">    blood: <span class="number">100</span>,</span><br><span class="line">    touch: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blood -= <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.blood == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'die'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="简单的工厂模式的实现"><a href="#简单的工厂模式的实现" class="headerlink" title="简单的工厂模式的实现"></a>简单的工厂模式的实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 简单工厂模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SmallPlane</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 只能创建很多个飞机，无法创建很多种飞机</span></span><br><span class="line">    <span class="keyword">this</span>.width = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.height = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'smallPlane'</span>;</span><br><span class="line">    <span class="keyword">this</span>.blood = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.touch = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blood -= <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.blood == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'die'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> SmallPlane();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BigPlane</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.width = <span class="number">150</span>;</span><br><span class="line">    <span class="keyword">this</span>.height = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">this</span>.blood = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'bigPlane'</span>;</span><br><span class="line">    <span class="keyword">this</span>.touch = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.blood -= <span class="number">50</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.blood == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'die'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> BigPlane();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AttackPlane</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.width = <span class="number">125</span>;</span><br><span class="line">    <span class="keyword">this</span>.height = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.blood = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'AttackPlane'</span>;</span><br><span class="line">    <span class="keyword">this</span>.touch = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">this</span>.attack = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'dadada~'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单工厂模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PlaneFactory</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newPlane = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'SmallPlane'</span>:</span><br><span class="line">            newPlane = <span class="keyword">new</span> SmallPlane();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"BigPlane"</span> :</span><br><span class="line">            newPlane = <span class="keyword">new</span> BigPlane();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"AttackPlane"</span>:</span><br><span class="line">            newPlane = <span class="keyword">new</span> AttackPlane();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    newPlane.die = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'boom'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newPlane;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PlaneFactory(<span class="string">'SmallPlane'</span>);</span><br></pre></td></tr></table></figure>



<h4 id="工厂方法模式的实现"><a href="#工厂方法模式的实现" class="headerlink" title="工厂方法模式的实现"></a>工厂方法模式的实现</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 工厂方法模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PlaneFactory</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工厂都可以使用的公共方法</span></span><br><span class="line">PlaneFactory.prototype.touch = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.blood -= <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.blood == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.die();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PlaneFactory.prototype.die = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'boom~'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象的接口</span></span><br><span class="line">PlaneFactory.create = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断以下是否存在该类型的子类工厂</span></span><br><span class="line">    <span class="keyword">if</span> (PlaneFactory.prototype[type] == <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'no this constructor'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 继承：子类继承父类的方法【把子类工厂的原型指向PlaneFactory，实现继承】</span></span><br><span class="line">    <span class="keyword">if</span>(PlaneFactory.prototype[type].prototype.__proto__ !== PlaneFactory.prototype) &#123;</span><br><span class="line">        PlaneFactory.prototype[type].prototype = <span class="keyword">new</span> PlaneFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> arg = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">  	<span class="comment">//也可以用apply实现参数传递</span></span><br><span class="line">    <span class="keyword">var</span> newPlane = <span class="keyword">new</span> PlaneFactory.prototype[type](...arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newPlane</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正定义子类工厂</span></span><br><span class="line">PlaneFactory.prototype.SmallPlane = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">    <span class="keyword">this</span>.width = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.height = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.blood = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'SmallPlane'</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PlaneFactory.prototype.BigPlane = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">    <span class="keyword">this</span>.width = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">this</span>.height = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">this</span>.blood = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'BigPlane'</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PlaneFactory.prototype.AttackPlane = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">    <span class="keyword">this</span>.width = <span class="number">150</span>;</span><br><span class="line">    <span class="keyword">this</span>.height = <span class="number">150</span>;</span><br><span class="line">    <span class="keyword">this</span>.blood = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'AttackPlane'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.attack = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'dadada'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oAp = PlaneFactory.create(<span class="string">'AttackPlane'</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> oSp = PlaneFactory.create(<span class="string">'SmallPlane'</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">var</span> oBp = PlaneFactory.create(<span class="string">'BigPlane'</span>, <span class="number">30</span>, <span class="number">40</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Git原理和常用命令以及我遇到的问题（知识点复习）</title>
    <url>/2020/07/11/git/</url>
    <content><![CDATA[<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><ul>
<li>设计理想是根据五维平衡宇宙的概念，可以穿梭在任意的时间点，对其修改和重置，而在git中最重要的两个概念就是版本管理（相当于可以任意进出历史和未来，并可以对其控制）和多人协作（平衡时空，可以把任意一段历史copy成很多份，每一份都可以进行修改，而且在多人修改之后，还可以多层次的平衡时空给合并了~）</li>
</ul>
<ul>
<li>可以把它想象成文件时光机，有了它就可以将某个文件夹回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态；还可以比较文件的变化细节，查出是谁的改修在哪里引入了问题代码，即使不小心删错了一些文件也能够通过它很方面的找回</li>
</ul>
<a id="more"></a>

<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ul>
<li>最重要的两个概念<strong>版本管理</strong>和<strong>多人协作</strong></li>
</ul>
<h3 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h3><p><strong>版本控制系统(version control system 简称VCS)，是一个记录一个或若干个文件内容变化，以便将来查阅特定版本修改情况的系统。</strong></p>
<h4 id="版本控制系统的演进"><a href="#版本控制系统的演进" class="headerlink" title="版本控制系统的演进"></a>版本控制系统的演进</h4><blockquote>
<p>分布式 ：真正的从控制系统克隆。版本库丢了，本地代码还是真实存在的</p>
</blockquote>
<blockquote>
<p>集中式：只是一个快照。如果版本库丢了，本地的快照也都没用</p>
</blockquote>
<p><img src="/2020/07/11/git/images/1593499472(1).jpg" alt="1593499472(1)"></p>
<h3 id="Git基础原理"><a href="#Git基础原理" class="headerlink" title="Git基础原理"></a>Git基础原理</h3><h4 id="增量变化"><a href="#增量变化" class="headerlink" title="增量变化"></a>增量变化</h4><blockquote>
<p>增量更新：版本之间，只记录变化，</p>
</blockquote>
<p><img src="/2020/07/11/git/images/1593499920(1).png" alt="1593499920(1)"></p>
<h4 id="全量变化"><a href="#全量变化" class="headerlink" title="全量变化"></a>全量变化</h4><blockquote>
<p>全量更新：无论是否变化，任何一个版本都有全部的快照</p>
</blockquote>
<p><img src="/2020/07/11/git/images/1593500065(1).jpg" alt="1593500065(1)"></p>
<h4 id="Git工作区及文件状态"><a href="#Git工作区及文件状态" class="headerlink" title="Git工作区及文件状态"></a>Git工作区及文件状态</h4><ul>
<li>工作目录[Working Diectory]：像vsCode和idea</li>
<li>暂存区[Staging Area(index)]：缓存区，一个一个的版本全是由缓存区的内容构成的，若干个版本形成了一个仓库，由指令把本地文件放入缓存区，再由指令把缓存区的版本形成一个一个的版本。</li>
<li>Git仓库[Repository]：若干版本构成的一个仓库</li>
<li>未提交过的文件：从untracked开始</li>
<li>提交过的文件：从modified开始</li>
</ul>
<p><img src="/2020/07/11/git/images/1593501005(1).jpg" alt="1593501005(1)"></p>
<h4 id="工作目录、暂存区、仓库之间的关系"><a href="#工作目录、暂存区、仓库之间的关系" class="headerlink" title="工作目录、暂存区、仓库之间的关系"></a>工作目录、暂存区、仓库之间的关系</h4><ul>
<li>头指针：指向最近一个版本的快照</li>
</ul>
<p><img src="/2020/07/11/git/images/1593501127(1).png" alt="1593501127(1)"></p>
<h3 id="日常开发中Git的使用"><a href="#日常开发中Git的使用" class="headerlink" title="日常开发中Git的使用"></a>日常开发中Git的使用</h3><ul>
<li><p>git init : 初始化一个空的git仓库，存在的各个版本的信息</p>
</li>
<li><p>U：未追踪的[未被记录的]</p>
</li>
<li><p>M: 已经保存过，但是又修改了</p>
</li>
<li><p>git add [文件 ]: 把要想存入缓存区的内容放到缓存区[git add index.html]</p>
</li>
<li><p>git commit</p>
<ul>
<li>不输入其他的：会打开linux下vm编辑器</li>
<li>摁i进入编辑</li>
<li>摁esc+:wq退出， wq：write quite，退出保存；q!:强制退出不保存</li>
</ul>
</li>
<li><p>git commit -m ‘版本说明”: 为本次提交的一个版本并且加上版本注释</p>
<ul>
<li>-m: message, </li>
</ul>
</li>
<li><p>git status: 查看最近操作状态</p>
</li>
<li><p>git rm -r –cached ‘files’: 在仓库中移除对应的文件</p>
</li>
<li><p>git checkout – file: 撤销上一下的保存【在未上传到缓存区和git仓库时，可以使用，如果以上传再checkout 是无效的】</p>
</li>
<li><p>git log：查看日志</p>
</li>
<li><p>git log –pretty=oneline: 一行展示日志</p>
</li>
<li><p>git 命令 -h: 查看命令的所有功能</p>
</li>
<li><p>git reset –hard  HEAD：版本回退</p>
<ul>
<li>git reset –hard HEAD^: 回退到上一版本【只能回退不能前进，^^: 回退到上上次, 几个^号就回退几次】</li>
<li>git reset –hard HEAD~2：回退到上上次版本【数字决定向前回退几次】</li>
<li>git reset –hard id: 回到指定id版本【获取id:利用git reflog查看版本id】</li>
<li>HEAD指针指向的是最近一次更新的版本</li>
<li>可以利用主键进行版本回退</li>
<li>主键算法：40位的16进制的数字组合而成，利加密算法[sha1-1:安全散列算法]进行排列</li>
</ul>
<p><img src="/2020/07/11/git/images/1593505856(1).jpg" alt="1593505856(1)"></p>
</li>
<li><p>git reflog: 查看历史版本</p>
</li>
<li><p>git revert  HEAD: 回退到某一个版本【把版本拿过来克隆一下，形成一个新的版本，不会影响源版本】</p>
</li>
<li><p>git revert –abort：取消版本回退</p>
</li>
<li><p>git diff: 比较工作区与暂存区</p>
</li>
<li><p>: 比较工作区与本地版本库最近一次commit的内容</p>
</li>
<li><p>git diff –cached : 比较暂存区与本地库中最近一次commit的内容</p>
</li>
<li><p>git diff <commit-id> <commit-id>: 比较两个commit之间的差异</commit-id></commit-id></p>
</li>
</ul>
<hr>
<h3 id="分支上的操作"><a href="#分支上的操作" class="headerlink" title="分支上的操作"></a>分支上的操作</h3><p>一般master作为主分支，部署的是bug最少的一个分支</p>
<ul>
<li>git branch <branch>: 创建新的分支</branch></li>
<li>git checkout <branch>：切换分支</branch></li>
<li>git branch: 查看所有分支</li>
<li>git checkout -b ‘分支名称’:  创建并切换到新的分支</li>
<li>git merge <branch>: 无冲突合并</branch></li>
<li>git branch -d <branch>: 删除分支</branch></li>
</ul>
<h3 id="文件暂存"><a href="#文件暂存" class="headerlink" title="文件暂存"></a>文件暂存</h3><ul>
<li>git stash save -a ‘message’: 添加改动到stash</li>
<li>git stash list: 查看stash列表</li>
<li>git stash pop &lt;stash@{id} &gt; ：恢复改动</li>
<li>git stash drop &lt;stash@{id} &gt; ：删除暂存</li>
<li>git stash clear: 删除全部暂存</li>
</ul>
<h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><ul>
<li>git remote add origin ‘远程仓库ssh地址’ : 关联远程仓库</li>
<li>ssh-keygen：设置远程密钥加密<ul>
<li>会产生一个公钥密钥和当前的服务器进行连接</li>
<li>在C:\Users\asus.ssh有个.pub文件在记事本中打开，复制一下</li>
<li>在githun中setting中SSH and GPG keys中 new ssh key<ul>
<li>title: 随便</li>
<li>key: 密钥粘贴进去</li>
<li>这样就完成了认证</li>
</ul>
</li>
</ul>
</li>
<li>git remote add origin ‘远程仓库ssh地址’：给远程仓库起一个名字叫origin</li>
<li>git push ‘远程仓库地址’ ‘分支’:：把本地内容推送到远程分支上</li>
<li>git pull origin ‘别的分支’: 把别的分支的内容拉到目前切换的分支上</li>
<li>部署settings -&gt; options -&gt; github page -&gt; 选择分支 -&gt; 会读取对应分支的index.html</li>
</ul>
<h3 id="【问题-】配置github"><a href="#【问题-】配置github" class="headerlink" title="【问题 】配置github"></a>【问题 】配置github</h3><ul>
<li>搜素DNS解析 -&gt; <a href="http://www.tool.chinaz.com(站长工具)" target="_blank" rel="noopener">www.tool.chinaz.com(站长工具)</a></li>
<li>搜索最快的TTL值</li>
<li>改下本地的hosts文件<ul>
<li>C盘 -&gt; Windows -&gt; System32 -&gt; drivers -&gt; etc -&gt; hosts文件</li>
<li>C:\Windows\System32\drivers\etc</li>
</ul>
</li>
</ul>
<h3 id="【问题】更新本地代码到远程仓库且合并"><a href="#【问题】更新本地代码到远程仓库且合并" class="headerlink" title="【问题】更新本地代码到远程仓库且合并"></a>【问题】更新本地代码到远程仓库且合并</h3><ol>
<li>git pull origin master</li>
<li>git add .</li>
<li>git commit -m ‘xxx’</li>
<li>git push origin master</li>
</ol>
<h3 id="【问题】切换不到远程仓库新的分支"><a href="#【问题】切换不到远程仓库新的分支" class="headerlink" title="【问题】切换不到远程仓库新的分支"></a>【问题】切换不到远程仓库新的分支</h3><ul>
<li>首先查看远程分支是否存在你需要的分支<ul>
<li>git brach -r</li>
</ul>
</li>
<li>然后更新下远程分支<ul>
<li>git remote update origin -p</li>
</ul>
</li>
<li>最后切换分支<ul>
<li>git checkout 分支名称</li>
</ul>
</li>
</ul>
<h3 id="【问题】-rejected-master-gt-master-non-fast-forward-error-failed-to-push-some-refs-to-‘http…’"><a href="#【问题】-rejected-master-gt-master-non-fast-forward-error-failed-to-push-some-refs-to-‘http…’" class="headerlink" title="【问题】[rejected]  master -&gt; master (non-fast-forward) error: failed to push some refs to ‘http…’"></a>【问题】[rejected]  master -&gt; master (non-fast-forward) error: failed to push some refs to ‘http…’</h3><ul>
<li>问题原因：本地仓库无法覆盖远程仓库</li>
<li>解决办法：消除差异之后再次覆盖<ul>
<li>git pull origin master // 把远程仓库和本地仓库同步</li>
<li>git add .</li>
<li>git commit -m ‘xxx’</li>
<li>git push origin master</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Git原理</category>
      </categories>
      <tags>
        <tag>Git原理</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-代理模式(知识点复习)</title>
    <url>/2020/07/11/designPattern/3.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><ul>
<li>在代理模式中，一个对象充当了另一个对象的接口。它与外观模式的区别之处在于，在外观模式中所拥有的是合并了多个方法调用的遍历方法。代理则介于对象的客户端和对象本身之间，并且对该对象的访问进行保护。</li>
<li>这种模式看起来可能像是额外的开销，但是出于性能因素的考虑它却非常有用。代理充当了某个对象的守护对象，并且试图使本体对象做尽可能少的工作。</li>
</ul>
<a id="more"></a>

<h3 id="设计模式-代理模式"><a href="#设计模式-代理模式" class="headerlink" title="设计模式-代理模式"></a>设计模式-代理模式</h3><ul>
<li>定义：为一个对象提供一种代理以控制对这个对象的访问</li>
<li>代理对象起到类似中介的作用，会增加一些功能（如：校验，合并等等），也会去一些愿有对象的功能</li>
<li>虚拟代理：虚拟代理是把一些开销很大的对象，延迟到真正需要它的时候才去创建执行<ul>
<li>图片加载，文件上传（合并网络请求）</li>
</ul>
</li>
<li>安全代理：控制真实对象的访问权限<ul>
<li>登录操作后才能看全功能，前端校验</li>
</ul>
</li>
<li>远程代理：一个对象将不同空间的对象进行局部代理<ul>
<li>监控多个对象的状态，总机监控分店</li>
</ul>
</li>
<li>智能代理：调用对象代理处理另外一些事情（如：垃圾回收机制，增加额外的服务）<ul>
<li>提供额外的其他服务，火车站代售处</li>
</ul>
</li>
</ul>
<h4 id="设计模式-代理模式-表单验证（保护代理）"><a href="#设计模式-代理模式-表单验证（保护代理）" class="headerlink" title="设计模式-代理模式-表单验证（保护代理）"></a>设计模式-代理模式-表单验证（保护代理）</h4><ul>
<li>保护代理就是起到保护作用，用来过滤掉一下不必要的请求，将真正需要的递给本体。</li>
<li>譬如，验证用户名是否唯一</li>
<li>这里应用的是保护代理的思想，如果用户名是不合法的，则不会将该请求给本体执行</li>
<li>发送ajax请求</li>
</ul>
<h4 id="设计模式-代理模式-反模式"><a href="#设计模式-代理模式-反模式" class="headerlink" title="设计模式-代理模式-反模式"></a>设计模式-代理模式-反模式</h4><ul>
<li>不能滥用模式，有时候仅仅给代码增加复杂度了</li>
</ul>
<h3 id="【例子】利用代理模式（虚拟代理）实现预加载和懒加载"><a href="#【例子】利用代理模式（虚拟代理）实现预加载和懒加载" class="headerlink" title="【例子】利用代理模式（虚拟代理）实现预加载和懒加载"></a>【例子】利用代理模式（虚拟代理）实现预加载和懒加载</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;div id=<span class="string">"demo"</span>&gt;</span><br><span class="line">  &lt;img src=<span class="string">""</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ js</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 代理模式 -&gt; 虚拟代理 -&gt; 实现懒加载和预加载</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 1. 预加载 -&gt; 1.jgp</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 首先要在计算机性能较好的时候，先发送一次，之后再用就是取缓存了</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 2. 懒加载 -&gt; 监控真正要展示的图片内容是否有被加载成功</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 提高用户体验的同时 减少对性能的伤害</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function MyImage(_id) &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 创建一个图片</span></span><br><span class="line"><span class="regexp">    var oImg = document.createElement('img');</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 设置图片路径</span></span><br><span class="line"><span class="regexp">    this.setSrc = function (_src) &#123;</span></span><br><span class="line"><span class="regexp">        oImg.src = _src;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 把图片放在id为_id的标签上;</span></span><br><span class="line"><span class="regexp">    document.getElementById(_id).appendChild(oImg);</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 代理</span></span><br><span class="line"><span class="regexp">var ProxyImage = (function (src) &#123;</span></span><br><span class="line"><span class="regexp">    var oImg = new Image(); /</span><span class="regexp">/ 真正需要加载的图片</span></span><br><span class="line"><span class="regexp">    var oMyImage = new MyImage('demo'); /</span><span class="regexp">/ 需要缓冲的图片</span></span><br><span class="line"><span class="regexp">    oImg.onload = function () &#123; /</span><span class="regexp">/ 检测真正加载的图片是否被加载完成</span></span><br><span class="line"><span class="regexp">        setTimeout(function () &#123; /</span><span class="regexp">/ 模拟网络延迟</span></span><br><span class="line"><span class="regexp">            oMyImage.setSrc(oImg.src); /</span><span class="regexp">/ 替换真正的图片</span></span><br><span class="line"><span class="regexp">        &#125;, 2000)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    return function (occupySrc, src) &#123;</span></span><br><span class="line"><span class="regexp">        oImg.src = src; /</span><span class="regexp">/ 设置真正需要加载图片饿路径</span></span><br><span class="line"><span class="regexp">        oMyImage.setSrc(occupySrc); /</span><span class="regexp">/ 缓存图片的地址</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;)();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ProxyImage('./im</span>ages/<span class="number">1.</span>jpg<span class="string">', '</span>http:<span class="comment">//img.pconline.com.cn/images/upload/upc/tx/wallpaper/1208/02/c0/12659156_1343874598198.jpg')</span></span><br></pre></td></tr></table></figure>

<h3 id="【例子】利用代理（虚拟代理）模式实现文件上传（减缓服务器压力）"><a href="#【例子】利用代理（虚拟代理）模式实现文件上传（减缓服务器压力）" class="headerlink" title="【例子】利用代理（虚拟代理）模式实现文件上传（减缓服务器压力）"></a>【例子】利用代理（虚拟代理）模式实现文件上传（减缓服务器压力）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;div id=<span class="string">"show"</span>&gt;xiaoliu&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;button type="bg"&gt;add greenBg&lt;/</span>button&gt;</span><br><span class="line">&lt;button type=<span class="string">"cl"</span>&gt;add blueColor&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button type="fs"&gt;add fontSize&lt;/</span>button&gt;</span><br><span class="line">&lt;button type=<span class="string">"fw"</span>&gt;add fontWeight&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button type="op"&gt;add opacity&lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理模式 -&gt; 虚拟代理 -&gt; 文件上传 </span></span><br><span class="line"><span class="keyword">var</span> oDiv = <span class="built_in">document</span>.getElementById(<span class="string">'show'</span>);</span><br><span class="line"><span class="keyword">var</span> oButtonArray = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'button'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚拟代理：控制对颜色变化的请求</span></span><br><span class="line"><span class="keyword">var</span> ProxyRequest = <span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cache = []; <span class="comment">// 缓存请求</span></span><br><span class="line">    <span class="keyword">var</span> timer = <span class="literal">null</span>; <span class="comment">// 定时器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回的函数</span></span><br><span class="line">        cache.push(<span class="keyword">this</span>.getAttribute(<span class="string">'type'</span>)); <span class="comment">// 缓存button</span></span><br><span class="line">        clearTimeout(timer); <span class="comment">// 清除上次的定时器</span></span><br><span class="line">        timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 2s后发出请求</span></span><br><span class="line">            <span class="comment">// cache =&gt; changeStyle</span></span><br><span class="line">            func(oDiv, cache); <span class="comment">// 执行函数</span></span><br><span class="line">            cache = []; <span class="comment">// 清空数组 -&gt; 清空上次的请求</span></span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A =&gt; C(代理) =&gt; B: 返回真正的请求函数</span></span><br><span class="line"><span class="keyword">var</span> realChangeStyle = ProxyRequest(changeStyle)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; oButtonArray.length; i++) &#123;</span><br><span class="line">    oButtonArray[i].onclick = realChangeStyle <span class="comment">// 为每个按钮绑定请求事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeStyle</span>(<span class="params">dom, typeArr</span>) </span>&#123; <span class="comment">// 能处理多次请求的函数 -&gt; 相当于请求后端服务器</span></span><br><span class="line">    <span class="comment">// type =&gt; dom style = value</span></span><br><span class="line">    <span class="keyword">var</span> typeObj = &#123;</span><br><span class="line">        bg: [<span class="string">'backgroundColor'</span>, <span class="string">'green'</span>],</span><br><span class="line">        cl: [<span class="string">'color'</span>, <span class="string">'blue'</span>],</span><br><span class="line">        fs: [<span class="string">'fontSize'</span>, <span class="string">'24px'</span>],</span><br><span class="line">        fw: [<span class="string">'fontWeight'</span>, <span class="string">'bold'</span>],</span><br><span class="line">        op: [<span class="string">'opacity'</span>, <span class="string">'0.3'</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (typeArr.constructor == <span class="built_in">Array</span>) &#123; <span class="comment">// 先判断type是不是数组</span></span><br><span class="line">        typeArr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">            dom.style[typeObj[item][<span class="number">0</span>]] = typeObj[item][<span class="number">1</span>];</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dom.style[typeObj[typeArr][<span class="number">0</span>]] = typeObj[typeArr][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="【例子】利用代理模式（保护代理）和策略模式优雅的处理表单验证"><a href="#【例子】利用代理模式（保护代理）和策略模式优雅的处理表单验证" class="headerlink" title="【例子】利用代理模式（保护代理）和策略模式优雅的处理表单验证"></a>【例子】利用代理模式（保护代理）和策略模式优雅的处理表单验证</h3><blockquote>
<p>利用策略模式创建一个能够处理校验规则的构造函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数 -&gt; 创建对象实例</span></span><br><span class="line"><span class="comment">// 迎合策略模式的一个对象</span></span><br><span class="line"><span class="comment">// 符合开闭原则</span></span><br><span class="line"><span class="comment">// add: 参数1:校验内容dom, 参数2: 错误信息显示dom，参数3: 校验规则</span></span><br><span class="line"><span class="comment">// add 添加校验规则（dom(校验谁), showDom(错误的信息展示到哪里),[&#123;strategy（策略）: 'isNonEmpty（策略实现）', errorMsg（错误返回的信息）: '用户名不为空'&#125;, &#123;strategy: 'maxLength:4', errorMsg: '用户名长度不能超过4'&#125;]）</span></span><br><span class="line"><span class="comment">// start 开始校验并返回真正的校验结果</span></span><br><span class="line"><span class="comment">// extend 可以扩展 算法 &#123;isMail(算法名称): function () &#123;&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Validator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.cache = []; <span class="comment">// 缓存作用 -&gt; 把所有执行的校验放入其中，等待start()执行</span></span><br><span class="line">    <span class="keyword">this</span>.warnDom = []; <span class="comment">// 存放提示信息标签的id -&gt; 清除上次的提示信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化校验规则</span></span><br><span class="line">Validator.prototype.strategies = &#123;</span><br><span class="line">    <span class="comment">// 判断是否为空</span></span><br><span class="line">    isNonEmpty: <span class="function"><span class="keyword">function</span> (<span class="params">value, errorMsg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="string">''</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 判断长度最大不能超过几</span></span><br><span class="line">    maxLength: <span class="function"><span class="keyword">function</span> (<span class="params">value, length, errorMsg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="string">''</span> &amp;&amp; value.length &gt; length) &#123;</span><br><span class="line">            <span class="keyword">return</span> errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 判断长度最小不能小于几</span></span><br><span class="line">    minLength: <span class="function"><span class="keyword">function</span> (<span class="params">value, length, errorMsg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="string">''</span> &amp;&amp; value.length &lt; length) &#123;</span><br><span class="line">            <span class="keyword">return</span> errorMsg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用校验规则 -&gt; 只调用，不触发</span></span><br><span class="line">Validator.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params">dom, showdom, strategyArr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 把提示标签放到warnDom里面</span></span><br><span class="line">    <span class="keyword">this</span>.warnDom.push(showdom)</span><br><span class="line">    strategyArr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index</span>) </span>&#123;</span><br><span class="line">        self.cache.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 把方法缓存到cache</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 'maxLength:4'.split[':'] ==&gt; ['maxLength', '4']</span></span><br><span class="line">            <span class="comment">// arr = ['isNonEmpty'] 第一圈</span></span><br><span class="line">            <span class="comment">// arr = ['maxLength', '4']  第二圈</span></span><br><span class="line">            <span class="keyword">var</span> arr = ele.stratrgy.split(<span class="string">':'</span>); <span class="comment">// 用冒号拆分</span></span><br><span class="line">            <span class="comment">// shift =&gt; 删除数组中第一个元素并返回</span></span><br><span class="line">            <span class="comment">// arr =&gt; [], ['4']</span></span><br><span class="line">            <span class="comment">// type =&gt; isNonEmpty maxLength</span></span><br><span class="line">            <span class="keyword">var</span> type = arr.shift();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// unshift: 把元素加到数组的第一位</span></span><br><span class="line">            <span class="comment">// [dom.value] [dom.value, '4']</span></span><br><span class="line">            arr.unshift(dom.value);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// [dom.value, errorMsg] [dom.value, '4', errorMsg]</span></span><br><span class="line">            arr.push(ele.errorMsg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 返回true或者false</span></span><br><span class="line">            <span class="keyword">var</span> msg = self.strategies[type].apply(self, arr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 这里只是提示，没有清空</span></span><br><span class="line">                showdom.innerText = msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发校验规则 -&gt; 返回校验处理信息 -&gt; true/false</span></span><br><span class="line">Validator.prototype.start = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="literal">true</span>; <span class="comment">// 标记最后是否能符合规则</span></span><br><span class="line">    <span class="keyword">this</span>.warnDom.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 每次提交之前先清空提示信息</span></span><br><span class="line">        ele.innerText = <span class="string">''</span>;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.cache.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">ele, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ele() != <span class="literal">true</span>) &#123; <span class="comment">// 判断执行之后的返回值是否等于true</span></span><br><span class="line">            flag = <span class="literal">false</span>; <span class="comment">// 如果有一个不是true最后flag就会等于false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展校验规则 -&gt; 把扩展的校验规则放入strategies中等待被调用</span></span><br><span class="line"></span><br><span class="line">Validator.prototype.extend = <span class="function"><span class="keyword">function</span> (<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// config是扩展放的总和 -&gt; 对象</span></span><br><span class="line">    <span class="comment">// 遍历每一个对象 -&gt; 把规则放到strategies中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> config) &#123;</span><br><span class="line">        Validator.prototype.strategies[prop] = config[prop];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>利用保护代理对表单进行验证</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html </span></span><br><span class="line">&lt;div&gt;</span><br><span class="line">   用户名：&lt;input type=<span class="string">"text"</span> id=<span class="string">"userDom"</span> name=<span class="string">"username"</span>&gt;     </span><br><span class="line">   &lt;span id=<span class="string">"showUser"</span>&gt;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">   密码：&lt;input type="password" id="psDom" name="code"&gt;</span></span><br><span class="line"><span class="regexp">   &lt;span id="showCode"&gt;&lt;/</span>span&gt;</span><br><span class="line">   邮箱：&lt;input type=<span class="string">"text"</span> id=<span class="string">"emDom"</span> name=<span class="string">"email"</span>&gt;</span><br><span class="line">   &lt;span id=<span class="string">"showEm"</span>&gt;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">   &lt;button id="submit"&gt;提交&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="./</span>validator.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// js</span></span><br><span class="line"><span class="string">// 代理模式 和 策略模式 结合</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// A =&gt; C(代理) =&gt; B</span></span><br><span class="line"><span class="string">function Request() &#123;</span></span><br><span class="line"><span class="string">    // 发送网络请求</span></span><br><span class="line"><span class="string">    console.log('send');</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 创建校验实例</span></span><br><span class="line"><span class="string">var validator = new Validator();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 增加扩展方法</span></span><br><span class="line"><span class="string">validator.extend(&#123;</span></span><br><span class="line"><span class="string">    isEmail: function (value, errorMsg) &#123;</span></span><br><span class="line"><span class="string">        if (value != '' &amp;&amp; value.indexOf('@') == -1) &#123;</span></span><br><span class="line"><span class="string">            return errorMsg;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return true;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    isPhone: function (value, errorMsg) &#123;</span></span><br><span class="line"><span class="string">        if(value != '' &amp;&amp; value.length != 11) &#123;</span></span><br><span class="line"><span class="string">            return errorMsg;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return true;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 保护代理：在请求发送之前，对参数进行校验</span></span><br><span class="line"><span class="string">var ProxyRequest = (function () &#123;</span></span><br><span class="line"><span class="string">    validator.add(userDom, showUser, [</span></span><br><span class="line"><span class="string">        &#123; stratrgy: 'isNonEmpty', errorMsg: '用户名不能为空' &#125;,</span></span><br><span class="line"><span class="string">        &#123; stratrgy: 'maxLength:4', errorMsg: '用户名长度不能超过4' &#125;</span></span><br><span class="line"><span class="string">    ]);</span></span><br><span class="line"><span class="string">    validator.add(psDom, showCode, [</span></span><br><span class="line"><span class="string">        &#123; stratrgy: 'isNonEmpty', errorMsg: '密码不能为空' &#125;,</span></span><br><span class="line"><span class="string">        &#123; stratrgy: 'minLength:6', errorMsg: '密码不能低于6位' &#125;</span></span><br><span class="line"><span class="string">    ]);</span></span><br><span class="line"><span class="string">    validator.add(emDom, showEm, [</span></span><br><span class="line"><span class="string">        &#123; stratrgy: 'isNonEmpty', errorMsg: '邮箱不能为空'&#125;,</span></span><br><span class="line"><span class="string">        &#123; stratrgy: 'isEmail', errorMsg: '请输入正确的邮箱格式'&#125;</span></span><br><span class="line"><span class="string">    ])</span></span><br><span class="line"><span class="string">    return function () &#123;</span></span><br><span class="line"><span class="string">        // Request();</span></span><br><span class="line"><span class="string">        if (validator.start() == true) &#123;</span></span><br><span class="line"><span class="string">            Request();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;)();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">submit.onclick = function () &#123;</span></span><br><span class="line"><span class="string">    ProxyRequest();</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-单例模式(知识点复习)</title>
    <url>/2020/07/11/designPattern/2.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><ul>
<li>单例模式的思想在于保证一个特定类仅有一个实例。这意味着当第二次使用同一个类创建新对象的时候，应该得到与第一次所创建对象完全相同的对象。</li>
<li>在Js中并没有类，但是Js中具有new语法可使用构造函数来创建对象，而且有时可能需要使用这种语法的单体实现。这种思想在于当使用同一个构造函数以new操作符创建多个对象时，应该仅获得指向完全相同的对象的新指针。</li>
<li>实现单例模式的方法有很多种，每一种都各有优缺点，下面总结出了每种的方法的实现和方法的优缺点</li>
<li>单例模式的实现思想<ul>
<li>判断是不是第一次创建实例<ul>
<li>是 -&gt; 创建实例</li>
<li>不是 -&gt; 返回第一次创建的实例</li>
<li>保证符合开闭原则</li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h4 id="使用构造函数中的静态属性来缓存该实例"><a href="#使用构造函数中的静态属性来缓存该实例" class="headerlink" title="使用构造函数中的静态属性来缓存该实例"></a>使用构造函数中的静态属性来缓存该实例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Test</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">       <span class="comment">// new的时候发生的事情</span></span><br><span class="line">       <span class="comment">// 1. var this = Object.create(Test.prototype);</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 判断是不是第一次new</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">typeof</span> Test.instance === <span class="string">'object'</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> Test.instance; <span class="comment">// 一个构造函数如果显式的返回了一个对象，就不会隐式的返回一个对象了</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">this</span>.name = name;</span><br><span class="line">       Test.instance = <span class="keyword">this</span>; <span class="comment">// 这样做的好处: 当你new对象时候，被永久保存在Test.instance（用构造函数的静态属性保存第一次创建的实例）</span></span><br><span class="line">     </span><br><span class="line">	   <span class="comment">// 隐式的返回</span></span><br><span class="line">       <span class="comment">// 2. return this;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> a = <span class="keyword">new</span> Test(<span class="string">'one'</span>);</span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(a === b); <span class="comment">// true</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 这样不符合开闭原则：可以随意的改变Test的属性和方法，也可以把Test给替换掉</span></span><br><span class="line"><span class="comment">2. 比如把Test.instance = null; 就会破坏了单例模式</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="使用闭包来保护该单个实例"><a href="#使用闭包来保护该单个实例" class="headerlink" title="使用闭包来保护该单个实例"></a>使用闭包来保护该单个实例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GO -&gt; Test</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// AO -&gt; instance == this</span></span><br><span class="line">    <span class="keyword">var</span> instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 产生闭包</span></span><br><span class="line">    <span class="comment">// 当第一次创建实例的时候，执行到这里会把父级Test函数换成此时的Test函数；</span></span><br><span class="line">    <span class="comment">// 又因为Test是挂在到全局的，此时就形成了闭包</span></span><br><span class="line">    <span class="comment">// 当以后的每次创建Test实例的时候，执行的都是下面的函数，</span></span><br><span class="line">    <span class="comment">// 返回的都是第一次创建的instance = this(第一次创建时的this)</span></span><br><span class="line">    Test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Test();</span><br><span class="line">Test.prototype.lastName = <span class="string">'liu'</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.lastName); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b.lastName); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Test); <span class="comment">// 函數</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 这样的创建单例模式也不是很好，</span></span><br><span class="line"><span class="comment">2. 虽然解决了开闭原则中的闭，但是无法解决开闭原则的开，就是无法添加扩展</span></span><br><span class="line"><span class="comment">3. 比如创建之后想要增加Test.prototype.lastName = 'a', 创建后的实例是无法访问到的，</span></span><br><span class="line"><span class="comment">4.因为a,b都是继承的原来的Test构造函数，此时给prototype填加方法是添加到闭包内的Test函数上了；</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="利用立即执行函数的特性缓存该实例"><a href="#利用立即执行函数的特性缓存该实例" class="headerlink" title="利用立即执行函数的特性缓存该实例"></a>利用立即执行函数的特性缓存该实例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Test = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> instance = <span class="literal">null</span>; <span class="comment">// 静态属性，保护单例对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>( instance !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> instance; <span class="comment">// 如果是第二次创建实例，就会把第一次创建的实例返回出去，这样就解决了无法从外部破坏单例对象</span></span><br><span class="line">  	&#125;</span><br><span class="line">    instance = <span class="keyword">this</span>;  <span class="comment">// 保存第一次创建的实例</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// return this; // 隐式返回</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Test();</span><br><span class="line">Test.prototype.lastName = <span class="string">'liu'</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a == b); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a.lastName); <span class="comment">// liu</span></span><br><span class="line"><span class="built_in">console</span>.log(b.lastName); <span class="comment">// liu</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 实现了开闭原则；</span></span><br><span class="line"><span class="comment">2. 利用闭包的原理把对象放到立即执行函数的静态属性instance上；</span></span><br><span class="line"><span class="comment">3. 没有改变Test的指针指向，可以扩展属性和方法。</span></span><br><span class="line"><span class="comment">4. 实现了单例模式</span></span><br><span class="line"><span class="comment">5. 不好的地方就是闭包保存的该实例，当该实例不用的时候，无法回收</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="【扩展】生产单例模式的函数"><a href="#【扩展】生产单例模式的函数" class="headerlink" title="【扩展】生产单例模式的函数"></a>【扩展】生产单例模式的函数</h4><ul>
<li>功能：把普通函数传入该函数，就会返回一个新的单例模式的函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getSingle = <span class="function"><span class="keyword">function</span> (<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result; <span class="comment">// 静态属性，存放第一次创建的实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!result) &#123; <span class="comment">//为空</span></span><br><span class="line">      result = func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 通过apply把传入的函数this和参数换成result;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result; <span class="comment">// 返回result</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="【写个例子】通过点击button按钮，生成同一个提示信息标签"><a href="#【写个例子】通过点击button按钮，生成同一个提示信息标签" class="headerlink" title="【写个例子】通过点击button按钮，生成同一个提示信息标签"></a>【写个例子】通过点击button按钮，生成同一个提示信息标签</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button id=<span class="string">'oBtn'</span>&gt;点击 &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 普通函数: 生成提示标签</span></span><br><span class="line"><span class="regexp">var CreateAlert = function (text) &#123;</span></span><br><span class="line"><span class="regexp">  var oDiv = document.createElement('div');</span></span><br><span class="line"><span class="regexp">  oDiv.style.display = 'none';</span></span><br><span class="line"><span class="regexp">  oDiv.innerHTML = text;</span></span><br><span class="line"><span class="regexp">  document.body.appendChild(oDiv);</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  return oDiv;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 单例模式的创造函数</span></span><br><span class="line"><span class="regexp">var getSingle = function (func) &#123;</span></span><br><span class="line"><span class="regexp">  var result; /</span><span class="regexp">/ 静态属性，存放第一次创建的实例</span></span><br><span class="line"><span class="regexp">  return function () &#123;</span></span><br><span class="line"><span class="regexp">    if(!result) &#123; /</span><span class="regexp">/为空</span></span><br><span class="line"><span class="regexp">      result = func.apply(this, arguments); /</span><span class="regexp">/ 通过apply把传入的函数this和参数换成result;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    return result; /</span><span class="regexp">/ 返回result</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 把普通函数变成单例模式</span></span><br><span class="line"><span class="regexp">var singleAlert = getSingle(CreateAlert);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/点击展示提示信息</span></span><br><span class="line"><span class="regexp">oBtn.onclick = function () &#123;</span></span><br><span class="line"><span class="regexp">  var timer = null;</span></span><br><span class="line"><span class="regexp">  clearTimeout(tiemr);</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  var oDiv = singleAlert('您已超时！');</span></span><br><span class="line"><span class="regexp">  oDiv.style.display = 'block';</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  timer = setTimeout(function () &#123;</span></span><br><span class="line"><span class="regexp">    oDiv.style.display = 'none'; /</span><span class="regexp">/ 两秒后消失</span></span><br><span class="line"><span class="regexp">  &#125;, 2000)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-六大原则（知识点复习）</title>
    <url>/2020/07/11/designPattern/1.%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><ul>
<li>代码质量的高低是素质，学会权衡才是高价值的开发经验</li>
<li>先原则，再模式<ul>
<li>原则是理论，模式是在理论上的具体方式，希望并建议考试100分，但都是理论具体还需要落在实际方式方法上，但不可以追求，其中有时间成本问题，用更多时间去玩还能保证不低的分数也是可以的。</li>
</ul>
</li>
</ul>
<h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><ul>
<li>设计模式（Design Pattern)是一套反复使用、多数人知晓的、经过分类的、代码设计经验的总结。</li>
</ul>
<h3 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h3><ul>
<li>使用设计模式的目的：为了代码可重复性、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样</li>
</ul>
<a id="more"></a>

<h3 id="模式是什么"><a href="#模式是什么" class="headerlink" title="模式是什么"></a>模式是什么</h3><ul>
<li><p>模式：模式是指从生产经验和生活经验中经过抽象和升华提炼出来的核心知识体系。模式（Pattern）其实就是解决某一类问题的方法论。</p>
</li>
<li><p>没有套路做事情没效率，很笨拙，重用性太小，情况再复杂的时候难度就很大，有了套路更容易的解决一些复杂的问题，让开发变的更高效。</p>
</li>
</ul>
<h3 id="创建型-研究高效的创建对象"><a href="#创建型-研究高效的创建对象" class="headerlink" title="创建型-研究高效的创建对象"></a>创建型-研究高效的创建对象</h3><ul>
<li>研究的是如何高效的创建对象</li>
</ul>
<ol>
<li>单例模式</li>
<li>抽象工厂模式</li>
<li>建造者模式</li>
<li>工厂模式</li>
<li>原型模式</li>
</ol>
<h3 id="结构型模式-设计对象的结构和关系"><a href="#结构型模式-设计对象的结构和关系" class="headerlink" title="结构型模式-设计对象的结构和关系"></a>结构型模式-设计对象的结构和关系</h3><ul>
<li>研究对象结构的关系</li>
</ul>
<ol>
<li>适配器模式</li>
<li>桥接模式</li>
<li>装饰模式</li>
<li>组合模式</li>
<li>外观模式</li>
<li>享元模式</li>
<li>代理模式</li>
</ol>
<h3 id="行为型模式-设计对象的行为"><a href="#行为型模式-设计对象的行为" class="headerlink" title="行为型模式-设计对象的行为"></a>行为型模式-设计对象的行为</h3><ol>
<li>模板方法模式</li>
<li>命令模式</li>
<li>迭代器模式</li>
<li>观察者模式</li>
<li>中介者模式</li>
<li>备忘录模式</li>
<li>解释器模式</li>
<li>状态模式</li>
<li>策略模式</li>
<li>职责链模式</li>
<li>访问者模式</li>
</ol>
<h3 id="谈一下设计模式的六大原则"><a href="#谈一下设计模式的六大原则" class="headerlink" title="谈一下设计模式的六大原则"></a>谈一下设计模式的六大原则</h3><ul>
<li>减少耦合，增强复用性，降低代码的开发维护扩展成本</li>
</ul>
<h4 id="谈下耦合度和复杂度"><a href="#谈下耦合度和复杂度" class="headerlink" title="谈下耦合度和复杂度"></a>谈下耦合度和复杂度</h4><ul>
<li>耦合关系是指两个事物之间如果存在一种相互作用、相互影响的关系、那么这种关系就称”耦合关系”</li>
<li>耦合度和复杂度的危害<ul>
<li>复杂度：高，代码质量不高，可维护性差，复用性差，不易扩展</li>
<li>耦合度：无，不可能，低，合理；过高不容易维护。但复用性和扩展性是好的。</li>
</ul>
</li>
</ul>
<h4 id="单一职责原则（single-Responsibility-principle）"><a href="#单一职责原则（single-Responsibility-principle）" class="headerlink" title="单一职责原则（single Responsibility principle）"></a>单一职责原则（single Responsibility principle）</h4><ul>
<li>一个方法只做一件事情，请求数据的函数就不要去渲染数据了</li>
</ul>
<h4 id="开闭原则-OCP"><a href="#开闭原则-OCP" class="headerlink" title="开闭原则 OCP"></a>开闭原则 OCP</h4><ul>
<li>一个软件实体如类、模块和函数应该对扩展开发，对修改关闭</li>
<li>面向扩展开发，面向修改关闭（jquery extend），同时增强代码复用性</li>
</ul>
<h4 id="里氏代换原则-L-Subsituation-Principle"><a href="#里氏代换原则-L-Subsituation-Principle" class="headerlink" title="里氏代换原则 L Subsituation Principle"></a>里氏代换原则 L Subsituation Principle</h4><ul>
<li>任何基类可以出现的地方，子类一定可以出现。通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。</li>
<li>比如一个父类可以访问的接口，父类忙着其他事情，子类可以去访问。</li>
</ul>
<h4 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则 DIP"></a>依赖倒置原则 DIP</h4><ul>
<li>最常用的原则，依赖接口，不依赖方法，底层的东西不用了解，我们只需要知道表现就可以。降低耦合度</li>
<li>前端应用中可以理解成多者之间依赖状态，而不依赖彼此。</li>
<li>js中没有接口的概念</li>
</ul>
<h4 id="接口分离原则-ISP"><a href="#接口分离原则-ISP" class="headerlink" title="接口分离原则 ISP"></a>接口分离原则 ISP</h4><ul>
<li>把大接口拆分小接口，不能一个接口全部实现增删改查</li>
</ul>
<h4 id="迪米特法则（最小知道原则）LD"><a href="#迪米特法则（最小知道原则）LD" class="headerlink" title="迪米特法则（最小知道原则）LD"></a>迪米特法则（最小知道原则）LD</h4><ul>
<li>一个接口和一个方法，传入的参数越少越好。降低耦合度的同时也会让复杂程度降低。</li>
<li>形成的关联越少越好，依赖最少。</li>
</ul>
<h3 id="开发时的流程"><a href="#开发时的流程" class="headerlink" title="开发时的流程"></a>开发时的流程</h3><ul>
<li>优先降低复杂度，尽量降低耦合度（基本都是通过增加耦合度，来降低复杂度的）<ul>
<li>利用单一职责原则，开闭原理，里氏代换原则降低复杂度（通过提高耦合度的方式去降低复杂度）</li>
<li>通过迪米特法则减少耦合</li>
<li>通过依赖倒置原则消除可以没有的耦合</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>华容道游戏最优解</title>
    <url>/2020/06/21/hyd/</url>
    <content><![CDATA[<p><a href="/hrd/hrd.html" title="华容道最优解">华容道最优解</a></p>
]]></content>
      <tags>
        <tag>华容道</tag>
      </tags>
  </entry>
</search>
